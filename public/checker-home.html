<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ki·ªÉm ƒë∆°n g√≥i h√†ng</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; connect-src 'self'">
    <script src="/serial-scanner.js"></script>
    <style>
        :root { --primary:#667eea; --accent:#764ba2; --ok:#22c55e; --warn:#f59e0b; --err:#ef4444; }
        body { font-family: 'Segoe UI', Arial, sans-serif; background: #0b1020; min-height: 100vh; margin: 0; }
        .container { width: 100%; max-width: 100%; margin: 0; background: #fff; border-radius: 0; box-shadow: none; padding: 0; overflow: hidden; min-height: 100vh; }
        .header { display: flex; align-items: center; justify-content: flex-start; gap: 12px; margin-bottom: 12px; }
        h1 { color: var(--primary); font-size: 22px; margin: 0; }
        .right { display: flex; align-items: center; gap: 8px; }
        .btn { padding: 14px 20px; background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%); color: #fff; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: 700; }
        .btn.secondary { background: #edf2ff; color: #3b5bdb; }
        .btn.danger { background: #e83e8c; }
        .input { width: 420px; max-width: 100%; font-size: 18px; padding: 16px 18px; border: 2px solid #eaeaea; border-radius: 12px; outline: none; background:#fff; font-weight: 500; }
        .input:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(102,126,234,0.15); }
        .hint { color: #555; margin: 8px 0 0; font-size: 16px; font-weight: 500; }
        .status { margin-top: 14px; font-size: 18px; font-weight: 600; }
        .status.ok { color: var(--ok); }
        .status.warn { color: var(--warn); }
        .status.err { color: var(--err); }
        .meta { margin-top: 16px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
        .tag { background:#f3f4f6; color:#111827; border-radius: 8px; padding: 6px 10px; font-size: 13px; }
        .row { display: grid; grid-template-columns: 1fr 1fr 1.2fr 1.6fr 1fr 0.9fr 0.9fr; gap: 12px; align-items: center; padding: 10px 12px; border-bottom: 1px solid #f1f5f9; }
        .row.header { font-weight: 700; color: #334155; background: #f8fafc; border-radius: 8px; position: sticky; top: 0; z-index: 2; }
        .rows { margin-top: 12px; max-height: calc(100vh - 260px); overflow: auto; border: 1px solid #f1f5f9; border-radius: 10px; }
        .badge { display:inline-block; padding: 4px 8px; border-radius: 999px; font-size: 12px; font-weight: 700; }
         .b-pending { background:#f8fafc; color:#475569; border: 2px solid #cbd5e1; font-weight: 600; }
         .b-progress { background:#fef3c7; color:#92400e; border: 2px solid #f59e0b; font-weight: 600; }
         .b-done { background:#d1fae5; color:#065f46; border: 2px solid #34d399; font-weight: 600; }
         .b-ready { background:#dbeafe; color:#1e40af; border: 2px solid #60a5fa; font-weight: 600; }
         .b-info { background:#e0f2fe; color:#0369a1; border: 2px solid #38bdf8; font-weight: 600; }
         .b-completed { background:#dcfce7; color:#166534; border: 2px solid #22c55e; font-weight: 700; box-shadow: 0 2px 4px rgba(34, 197, 94, 0.2); }
         .b-processing { background:#fef3c7; color:#92400e; border: 2px solid #f59e0b; font-weight: 700; box-shadow: 0 2px 4px rgba(245, 158, 11, 0.2); }
        .b-error { background:#fee2e2; color:#b91c1c; border: 1px solid #ef4444; }
        .row-done { background:#f0fdf4; }
        .row-progress { background:#fff7ed; }
         
         /* Row colors based on status */
         .row.status-pending { background:#fafbfc; border-left: 4px solid #d1d5db; }
         .row.status-processing { background:#fffbeb; border-left: 4px solid #f59e0b; }
         .row.status-completed { background:#f0fdf4; border-left: 4px solid #22c55e; }
         
         /* Hover effects for rows */
         .row:hover { background:#f8fafc; transition: background-color 0.2s ease; }
         .row.status-pending:hover { background:#f1f5f9; }
         .row.status-processing:hover { background:#fef3c7; }
         .row.status-completed:hover { background:#dcfce7; }
         
         /* Status indicator dots */
         .status-indicator {
             display: inline-block;
             width: 8px;
             height: 8px;
             border-radius: 50%;
             margin-right: 6px;
         }
         .status-indicator.pending { background: #9ca3af; }
         .status-indicator.processing { background: #f59e0b; }
         .status-indicator.completed { background: #22c55e; }
        .progress { margin-top: 10px; height: 10px; background:#f3f4f6; border-radius: 999px; overflow: hidden; }
        .bar { height: 100%; width: 0%; background: linear-gradient(90deg, #34d399, #10b981); transition: width .25s ease; }
        .empty { text-align:center; color:#64748b; padding: 28px; }
        .layout { display: grid; grid-template-columns: 240px 1fr; min-height: 80vh; }
        .sidebar { background:#0f172a; color:#cbd5e1; height: 100%; padding: 16px; }
        .sidebar .nav-btn { width: 100%; text-align: left; background: transparent; border: 1px solid rgba(148,163,184,.2); color:#e2e8f0; padding: 10px 12px; border-radius: 8px; cursor: pointer; margin-bottom: 10px; }
        .sidebar .nav-btn.active { background:#1e293b; border-color:#334155; }
        .sidebar .nav-btn:disabled { opacity: .5; cursor: not-allowed; }
        .content { padding: 20px 24px; }
        .flash { animation: flashBg 1200ms ease-out; }
        @keyframes flashBg { 0% { background:#ecfdf5; } 100% { background:transparent; } }
        .spinner { width:16px; height:16px; border:2px solid #e5e7eb; border-top-color:#6366f1; border-radius:50%; animation: spin .8s linear infinite; display:none; }
        .spinner.show { display:inline-block; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .banner { padding: 12px 14px; border-radius: 10px; margin: 10px 0; font-size: 14px; }
        .banner.warn { background:#fffbeb; color:#92400e; border:1px solid #f59e0b33; }
        .banner.err { background:#fef2f2; color:#991b1b; border:1px solid #ef444433; }
        .dropzone { border:2px dashed #475569; border-radius: 10px; padding: 18px; color:#e2e8f0; text-align:center; background:#0b1220; }
        .dropzone.drag { background:#0e1a31; border-color:#64748b; }
        .upload-actions { display:flex; gap:10px; margin-top:12px; justify-content:center; }
        .filename { margin-top: 10px; color:#e2e8f0; font-size: 14px; }
        .progress-line { margin-top: 12px; height: 10px; background:#1f2937; border-radius: 999px; overflow: hidden; }
        .progress-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #60a5fa, #34d399); transition: width .2s ease; }
        .toast { position: fixed; right: 16px; bottom: 16px; background: #111827; color:#e5e7eb; padding: 10px 14px; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,.25); display:none; }
        .toast.show { display:block; }
        
        /* Stats Styles */
        .stats-container { padding: 20px; background: #fff; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .stats-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
        .stats-title { font-size: 24px; font-weight: 700; color: var(--primary); margin: 0; }
        .date-picker-container { display: flex; align-items: center; gap: 12px; }
        .date-picker { padding: 8px 12px; border: 2px solid #eaeaea; border-radius: 8px; font-size: 14px; }
        .date-picker:focus { border-color: var(--primary); outline: none; }
        .btn-refresh { padding: 8px 16px; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; }
        .btn-refresh:hover { background: var(--accent); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin-top: 20px; }
    .stats-card { background: linear-gradient(180deg, #ffffff, #fbfdff); border-radius: 12px; padding: 18px; border-left: 6px solid var(--primary); box-shadow: 0 6px 18px rgba(15, 23, 42, 0.06); display:flex; flex-direction:column; gap:8px; }
    .stats-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .stats-card-title { font-size: 15px; font-weight: 700; color: #0f172a; margin: 0; display:flex; align-items:center; gap:10px; }
    .stat-icon { width:36px; height:36px; border-radius:10px; display:inline-flex; align-items:center; justify-content:center; font-size:18px; color:white; box-shadow: 0 6px 12px rgba(15,23,42,0.08); }
    .stat-icon.orders { background: linear-gradient(135deg,#3b82f6,#1d4ed8); }
    .stat-icon.items { background: linear-gradient(135deg,#34d399,#10b981); }
    .stat-icon.employees { background: linear-gradient(135deg,#f59e0b,#f97316); }
    .stats-card-value { font-size: 34px; font-weight: 900; color: #0f172a; margin: 4px 0; letter-spacing: -0.02em; }
    .stats-card-value .muted { font-size: 14px; font-weight: 600; color: #64748b; display:block; margin-top:6px; }
    .stats-card-detail { font-size: 13px; color: #475569; }
    .card-progress { height:10px; background:#eef2ff; border-radius:999px; overflow:hidden; margin-top:8px; }
    .card-progress > .fill { height:100%; width:0%; background: linear-gradient(90deg,#3b82f6,#6366f1); transition: width .5s ease; }
        .stats-table { width: 100%; border-collapse: collapse; margin-top: 20px; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .stats-table th, .stats-table td { padding: 12px 16px; text-align: left; border-bottom: 1px solid #e2e8f0; }
        .stats-table th { background: #f8fafc; font-weight: 600; color: #334155; }
        .stats-table tr:hover { background: #f8fafc; }
        .loading-stats { text-align: center; padding: 40px; color: #64748b; }
        .error-stats { text-align: center; padding: 40px; color: var(--err); }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(4px);
        }
        
        .modal-overlay.show {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }
        
        .modal {
            background: white;
            border-radius: 20px;
            padding: 50px;
            max-width: 600px;
            width: 95%;
            text-align: center;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            transform: scale(0.8);
            animation: modalSlideIn 0.3s ease-out forwards;
        }
        
        .modal.compact {
            padding: 40px;
            max-width: 500px;
        }
        
        .modal-icon {
            display: none !important;
        }
        
        .modal-icon.success { color: #22c55e; }
        .modal-icon.error { color: #ef4444; }
        .modal-icon.warning { color: #f59e0b; }
        .modal-icon.info { color: #3b82f6; }
        
        /* Modal background colors */
        .modal.success {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border: 3px solid #22c55e;
            box-shadow: 0 20px 40px rgba(34, 197, 94, 0.2);
        }
        
        .modal.error {
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            border: 3px solid #ef4444;
            box-shadow: 0 20px 40px rgba(239, 68, 68, 0.2);
        }
        
        .modal.warning {
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
            border: 3px solid #f59e0b;
            box-shadow: 0 20px 40px rgba(245, 158, 11, 0.2);
        }
        
        .modal.info {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border: 3px solid #3b82f6;
            box-shadow: 0 20px 40px rgba(59, 130, 246, 0.2);
        }
        
        .modal.question {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 3px solid #64748b;
            box-shadow: 0 20px 40px rgba(100, 116, 139, 0.2);
        }
        
        /* Modal animations */
        .modal {
            transition: all 0.3s ease;
            transform: scale(0.9);
            opacity: 0;
        }
        
        .modal-overlay.show .modal {
            transform: scale(1);
            opacity: 1;
        }
        
        /* Pulse animation for success modal */
        .modal.success {
            animation: successPulse 0.6s ease-out;
        }
        
        @keyframes successPulse {
            0% { transform: scale(0.9); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Shake animation for error modal */
        .modal.error {
            animation: errorShake 0.6s ease-out;
        }
        
        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        
        /* Bounce animation for warning modal */
        .modal.warning {
            animation: warningBounce 0.6s ease-out;
        }
        
        @keyframes warningBounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        .modal-title {
            font-size: 2.2rem;
            font-weight: 800;
            margin-bottom: 20px;
            color: #1f2937;
        }
        
        .modal-message {
            font-size: 1.5rem;
            color: #374151;
            line-height: 1.8;
            margin-bottom: 35px;
            font-weight: 500;
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .modal-btn {
            padding: 18px 36px;
            border: none;
            border-radius: 15px;
            font-size: 1.4rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        
        .modal-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .modal-btn.secondary {
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #e5e7eb;
        }
        
        .modal-btn.danger {
            background: #ef4444;
            color: white;
        }
        
        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .modal-btn:active {
            transform: translateY(0);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes modalSlideIn {
            from { 
                transform: scale(0.8) translateY(-50px);
                opacity: 0;
            }
            to { 
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        @media (max-width: 600px) {
            .modal {
                padding: 30px 20px;
                margin: 20px;
            }
            
            .modal-icon {
                font-size: 3rem;
            }
            
            .modal-title {
                font-size: 1.5rem;
            }
            
            .modal-message {
                font-size: 1.1rem;
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .modal-btn {
                width: 100%;
                max-width: 200px;
            }
        }
        .queue { display:flex; gap:8px; flex-wrap:wrap; margin: 8px 0 0; }
        .qitem { display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius: 999px; background:#eef2ff; color:#3730a3; border:2px solid #e5e7eb; font-weight: 600; font-size: 14px; }
        .qitem.active { background:#dbeafe; border-color:#3b82f6; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3); }
        .qitem.pending { background:#f3f4f6; color:#374151; border-color:#9ca3af; }
        .qitem.processing { background:#fef3c7; color:#92400e; border-color:#f59e0b; }
        .qitem.completed { background:#dcfce7; color:#166534; border-color:#22c55e; }
        .qtext { cursor:pointer; font-size: 16px; font-weight: 700; }
        .qbtn { cursor:pointer; color:#991b1b; background:#fee2e2; border:1px solid #fecaca; padding:2px 6px; border-radius: 8px; font-size: 12px; }
    </style>
    <script>
        // L·∫•y token cho tab hi·ªán t·∫°i (∆∞u ti√™n auth_token, fallback checkerAuthToken)
        function getAuthToken() {
            return sessionStorage.getItem('auth_token') || sessionStorage.getItem('checkerAuthToken') || '';
        }

        // H√†m l∆∞u user behaviour
        async function saveUserBehaviour(method, description, metadata = {}) {
            try {
                const response = await fetch('/api/user-behaviour', {
                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + getAuthToken()
                    },
                    body: JSON.stringify({
                        method,
                        description,
                        metadata
                    })
                });
                
                const result = await response.json();
                if (!result.success) {
                }
            } catch (error) {
            }
        }
    </script>
</head>
<body>
    <div class="container">
        <div class="layout" id="layout">
            <div class="sidebar" id="sidebar">
                <div class="header" style="margin-bottom:12px;">
                    <h1 style="color:#e2e8f0;">Checker</h1>
                </div>
                <button id="viewBtn" class="nav-btn active">Xem ƒë∆°n h√†ng</button>
                <button id="cancelledBtn" class="nav-btn">Xem ƒë∆°n h·ªßy</button>
                <button id="statsBtn" class="nav-btn">Th·ªëng k√™</button>
                <button id="uploadBtn" class="nav-btn">Upload file</button>
                <button id="checkBtn" class="nav-btn">Check ƒë∆°n</button>
                <div style="height:16px;"></div>
                <div style="display:flex;flex-direction:column;gap:8px;">
                    <span class="tag" id="userTag">...</span>
                    <span class="tag" id="maVanDonTag">Ch∆∞a ch·ªçn</span>
                </div>
                <button id="logoutBtn" class="btn danger" style="margin-top:18px; display: none;">ƒêƒÉng xu·∫•t</button>
            </div>
            <div class="content" id="content">
                <div id="metaWrap" class="meta">
                    <span id="progressText" style="font-size: 16px; font-weight: 600;">0/0 ho√†n th√†nh ¬∑ 0/0 ƒë√£ qu√©t</span>
                    <div class="progress"><div class="bar" id="bar"></div></div>
                </div>
                <div id="queue" class="queue"></div>
                
                <!-- Scanner Info Section -->
                <div class="scanner-info" style="margin: 18px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                    <h4 style="margin-bottom: 10px; color: #495057; font-size: 16px;">üîß Th√¥ng tin m√°y qu√©t</h4>
                    <div id="scannerInfo" style="padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd;">
                        <div id="noScannerInfo" style="color: #666; text-align: center;">
                            <p>üìã Admin ch∆∞a ph√¢n quy·ªÅn m√°y qu√©t cho b·∫°n</p>
                            <p style="font-size: 14px; margin-top: 5px;">Li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c ph√¢n quy·ªÅn m√°y qu√©t</p>
                        </div>
                        <div id="scannerDetails" style="display: none;">
                            <div style="margin-bottom: 10px;">
                                <strong>M√°y qu√©t ƒë∆∞·ª£c ph√©p:</strong> <span id="allowedScanners"></span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <strong>M√°y qu√©t hi·ªán t·∫°i:</strong> <span id="currentAssignedScanner"></span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <strong>C·ªïng:</strong> <span id="assignedPort"></span>
                            </div>
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e9ecef;">
                                <button id="connectComBtn" class="btn" style="font-size: 14px; padding: 10px 16px; background: #2196f3;">
                                    üîå K·∫øt n·ªëi m√°y qu√©t COM
                                </button>
                                <span id="comStatus" style="margin-left: 10px; font-weight: 600;"></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="inputWrap" style="margin-top:18px;">
                    <input id="codeInput" class="input" placeholder="Nh·∫≠p m√£ v·∫≠n ƒë∆°n ho·∫∑c m√£ h√†ng..." autocomplete="off" />
                    <span id="spin" class="spinner"></span>
                </div>
                <div id="status" class="status"></div>
                <div id="rows" class="rows"></div>
                <div id="uploadPanel" style="display:none;margin-top:18px;">
                    <div class="dropzone" id="dropzone">K√©o th·∫£ file Excel ƒë∆°n h√†ng v√†o ƒë√¢y ho·∫∑c ch·ªçn file b√™n d∆∞·ªõi</div>
                    <div class="upload-actions">
                        <input type="file" id="filePicker" accept=".xlsx,.xls" style="display:inline-block;" />
                        <button id="doUpload" class="btn">Upload ƒë∆°n h√†ng</button>
                    </div>
                    <div id="fileName" class="filename"></div>
                    <div class="progress-line" style="display:none;width:100%;"><div class="progress-bar" id="uploadBar"></div></div>
                </div>
                <div id="uploadMasterPanel" style="display:none;margin-top:18px;">
                    <div class="dropzone" id="dropzoneMaster">K√©o th·∫£ file MasterData Excel v√†o ƒë√¢y ho·∫∑c ch·ªçn file b√™n d∆∞·ªõi</div>
                    <div class="upload-actions">
                        <input type="file" id="fileMasterPicker" accept=".xlsx,.xls" style="display:inline-block;" />
                        <button id="doUploadMaster" class="btn">Upload MasterData</button>
                    </div>
                    <div id="fileMasterName" class="filename"></div>
                    <div class="progress-line" style="display:none;width:100%;"><div class="progress-bar" id="uploadMasterBar"></div></div>
                </div>
                <div id="uploadComboPanel" style="display:none;margin-top:18px;">
                    <div class="dropzone" id="dropzoneCombo">K√©o th·∫£ file ComboData Excel v√†o ƒë√¢y ho·∫∑c ch·ªçn file b√™n d∆∞·ªõi</div>
                    <div class="upload-actions">
                        <input type="file" id="fileComboPicker" accept=".xlsx,.xls" style="display:inline-block;" />
                        <button id="doUploadCombo" class="btn">Upload ComboData</button>
                        <button id="fixComboData" class="btn secondary" style="margin-left:8px;">Fix ComboData</button>
                    </div>
                    <div id="fileComboName" class="filename"></div>
                    <div class="progress-line" style="display:none;width:100%;"><div class="progress-bar" id="uploadComboBar"></div></div>
                </div>
                
                <div id="toast" class="toast"></div>
            </div>
        </div>
        
        <!-- Modal Container -->
        <div id="modalOverlay" class="modal-overlay">
            <div id="modal" class="modal">
                <div id="modalIcon" class="modal-icon"></div>
                <div id="modalTitle" class="modal-title"></div>
                <div id="modalMessage" class="modal-message"></div>
                <div id="modalButtons" class="modal-buttons"></div>
            </div>
        </div>
    </div>
    <script>
        let currentMaVanDon = '';
let currentPage = 1;
let pageSize = 20;
        let cacheOrders = [];
        
        // Function ƒë·ªÉ track cacheOrders changes
        function setCacheOrders(newValue, source = 'unknown') {
            if (!Array.isArray(newValue)) {
                cacheOrders = [];
            } else {
            cacheOrders = newValue;
                
                // Reset currentPage to 1 only when manually loading new data, not during polling
                if ((source === 'loadAllOrdersFromDB' || source === 'loadAllOrders') && activeView === 'view' && source !== 'polling') {
                    currentPage = 1;
                }
            }
        }
        let isLoading = false;
        let activeView = 'view'; // 'view' | 'upload' | 'check'
        let userRole = 'checker';
        const queueMap = new Map(); // maVanDon -> { orders:[], completed:boolean }
        const queueList = []; // gi·ªØ th·ª© t·ª± ƒë∆°n ƒëang x·ª≠ l√Ω
        
        // Tr·∫°ng th√°i quy tr√¨nh check ƒë∆°n
        let orderCheckState = 'idle'; // 'idle', 'scanning', 'completed'
        let scannedItems = []; // Danh s√°ch c√°c m·∫∑t h√†ng ƒë√£ qu√©t
        let currentVanDonStatus = null; // L∆∞u tr·∫°ng th√°i c·ªßa maVanDon hi·ªán t·∫°i
        let waitingForNewOrder = false; // ƒêang ch·ªù input ƒë∆°n m·ªõi (ƒë∆°n hi·ªán t·∫°i ƒë√£ ho√†n th√†nh)
        let pollingInterval = null; // Interval cho polling ƒë·ªãnh k·ª≥
        let lastPollingTime = 0; // Th·ªùi gian polling cu·ªëi c√πng
        
        // ========== STATE MACHINE PATTERN ==========
        
        // ƒê·ªãnh nghƒ©a c√°c tr·∫°ng th√°i
        const CheckStates = {
            IDLE: 'idle',
            ORDER_ACTIVE: 'order_active',
            SCANNING: 'scanning',
            ORDER_COMPLETED: 'order_completed'
        };
        
        // Class State Machine cho Order Check
        class OrderCheckStateMachine {
            constructor() {
                this.state = CheckStates.IDLE;
                this.currentOrder = null;
                this.scannedItems = [];
                this.cacheOrders = [];
                this.isLoading = false;
            }
            
            // Ki·ªÉm tra input c√≥ h·ª£p l·ªá kh√¥ng
            isValidInput(code) {
                return code && code.length >= 3;
            }
            
            // Ki·ªÉm tra xem code c√≥ v·∫ª nh∆∞ m√£ v·∫≠n ƒë∆°n kh√¥ng
            looksLikeVanDon(code) {
                const dashCount = (code.match(/-/g) || []).length;
                return dashCount === 0; // Kh√¥ng c√≥ d·∫•u g·∫°ch ngang = m√£ ƒë∆°n
            }
            
            // Ph√¢n lo·∫°i input
            classifyInput(code) {
                if (!this.isValidInput(code)) {
                    return 'INVALID_INPUT';
                }
                
                const isVanDonCode = this.looksLikeVanDon(code);
                
                if (isVanDonCode) {
                    if (code === this.currentOrder?.maVanDon) {
                        // Qu√©t l·∫°i ƒë∆°n hi·ªán t·∫°i = CHECK-IN l·∫°i (ti·∫øp t·ª•c qu√©t)
                        return 'CURRENT_ORDER_CHECKIN';
                    } else if (this.currentOrder) {
                        // Qu√©t ƒë∆°n kh√°c = KH√îNG cho ph√©p chuy·ªÉn, y√™u c·∫ßu ho√†n th√†nh ƒë∆°n hi·ªán t·∫°i
                        return 'DIFFERENT_ORDER_BLOCKED';
                    } else {
                        // Ch∆∞a c√≥ ƒë∆°n n√†o = check-in ƒë∆°n m·ªõi
                        return 'NEW_ORDER_CHECKIN';
                    }
                } else {
                    if (this.currentOrder) {
                        // Ki·ªÉm tra xem code c√≥ ph·∫£i l√† m√£ h√†ng trong ƒë∆°n hi·ªán t·∫°i kh√¥ng
                        const isValidItem = this.isValidItemInCurrentOrder(code);
                        if (isValidItem) {
                            return 'ITEM_SCAN';
                        } else {
                            return 'INVALID_ITEM_FOR_ORDER';
                        }
                    } else {
                        return 'ITEM_WITHOUT_ORDER';
                    }
                }
            }
            
            // Ki·ªÉm tra m√£ h√†ng c√≥ h·ª£p l·ªá trong ƒë∆°n hi·ªán t·∫°i kh√¥ng
            isValidItemInCurrentOrder(code) {
                if (!this.currentOrder || !this.cacheOrders.length) {
                    return false;
                }
                
                // Ki·ªÉm tra xem code c√≥ match v·ªõi pattern m√£ h√†ng trong ƒë∆°n kh√¥ng
                return this.cacheOrders.some(order => {
                    if (!order.maHang) return false;
                    
                    // Ki·ªÉm tra exact match tr∆∞·ªõc
                    if (order.maHang === code) {
                        return true;
                    }
                    
                    // Ki·ªÉm tra combo item pattern
                    if (this.isComboItem(code, order.maHang)) {
                        return true;
                    }
                    
                    // Ki·ªÉm tra partial match (code c√≥ ch·ª©a maHang base)
                    const baseMaHang = order.maHang.split('-')[0]; // L·∫•y ph·∫ßn base
                    if (code.includes(baseMaHang) && code.includes('-')) {
                        return true;
                    }
                    
                    return false;
                });
            }
            
            // Ki·ªÉm tra xem c√≥ ph·∫£i combo item kh√¥ng
            isComboItem(code, maHang) {
                // Logic ki·ªÉm tra combo item (c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh theo y√™u c·∫ßu c·ª• th·ªÉ)
                if (!maHang || !code) return false;
                
                // Ki·ªÉm tra pattern combo: maHang-base + code-suffix
                const dashCount = (code.match(/-/g) || []).length;
                if (dashCount >= 2) {
                    // C√≥ th·ªÉ l√† combo item
                    return true;
                }
                
                return false;
            }
            
            // Ki·ªÉm tra ƒë∆°n c√≥ ho√†n th√†nh kh√¥ng - ƒê·∫øm s·ªë l·∫ßn qu√©t th·ª±c t·∫ø
            isOrderCompletedSync() {
                if (!this.currentOrder || !this.cacheOrders.length) return false;
                
                // ƒê·∫øm s·ªë l·∫ßn qu√©t th·ª±c t·∫ø cho t·ª´ng m√£ h√†ng
                let totalScanned = 0;
                this.cacheOrders.forEach(order => {
                    const scannedItemsForThisProduct = this.scannedItems.filter(item => item.maHang === order.maHang);
                    totalScanned += scannedItemsForThisProduct.length;
                });
                
                const totalRequired = this.cacheOrders.reduce((sum, order) => sum + order.soLuong, 0);
                
                return totalScanned >= totalRequired;
            }
            
            
            
            // Ki·ªÉm tra ƒë∆°n c√≥ ƒëang ƒë∆∞·ª£c qu√©t kh√¥ng
            isOrderInProgress() {
                return this.state === CheckStates.SCANNING && this.scannedItems.length > 0;
            }
            
            // X·ª≠ l√Ω input ch√≠nh
            async handleInput(code) {
                if (this.isLoading) {
                    return;
                }
                
                try {
                    this.isLoading = true;
                    
                    // Ki·ªÉm tra n·∫øu ƒëang ·ªü tr·∫°ng th√°i IDLE (trang r·ªóng) v√† input l√† m√£ v·∫≠n ƒë∆°n
                    if (this.state === CheckStates.IDLE && this.looksLikeVanDon(code)) {
                        await this.checkinOrder(code);
                        return;
                    }
                    
                    const inputType = this.classifyInput(code);
                    
                    switch (inputType) {
                        case 'INVALID_INPUT':
                            this.showError('Input kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p l·∫°i.');
                            break;
                            
                        case 'ITEM_WITHOUT_ORDER':
                            this.showError('Ch∆∞a ch·ªçn m√£ v·∫≠n ƒë∆°n. H√£y nh·∫≠p m√£ v·∫≠n ƒë∆°n tr∆∞·ªõc.');
                            break;
                            
                        case 'INVALID_ITEM_FOR_ORDER':
                            this.showError(`M√£ h√†ng "${code}" kh√¥ng thu·ªôc ƒë∆°n ${this.currentOrder.maVanDon}. Vui l√≤ng qu√©t m√£ h√†ng ƒë√∫ng ho·∫∑c qu√©t ƒë∆°n kh√°c.`);
                            break;
                            
                        case 'DIFFERENT_ORDER_BLOCKED':
                            await this.handleDifferentOrderBlocked(code);
                            break;
                            
                        case 'CURRENT_ORDER_CHECKIN':
                            await this.handleCurrentOrderCheckin();
                            break;
                            
                        case 'NEW_ORDER_CHECKIN':
                            await this.checkinOrder(code);
                            break;
                            
                        case 'ITEM_SCAN':
                            await this.scanItem(code);
                            break;
                            
                        default:
                            this.showError('Lo·∫°i input kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£.');
                    }
                    
                } catch (error) {
                    this.showError(error.message || 'C√≥ l·ªói x·∫£y ra');
                } finally {
                    this.isLoading = false;
                    // Ch·ªâ focus input n·∫øu kh√¥ng c√≥ modal ƒëang hi·ªÉn th·ªã
                    if (!document.getElementById('modalOverlay').classList.contains('show')) {
                        this.ensureInputFocus();
                    }
                }
            }
            
            // X·ª≠ l√Ω qu√©t l·∫°i ƒë∆°n hi·ªán t·∫°i
            async handleCurrentOrderCheckin() {
                // ƒê√≥ng modal n·∫øu ƒëang hi·ªÉn th·ªã
                hideModal();
                
                // Ki·ªÉm tra tr·∫°ng th√°i ƒë∆°n hi·ªán t·∫°i
                const isCompleted = this.isOrderCompletedSync();
                
                if (isCompleted) {
                    // ƒê∆°n ƒë√£ ho√†n th√†nh - t·ª± ƒë·ªông ho√†n th√†nh ƒë∆°n
                    await this.completeOrder();
                } else {
                    // ƒê∆°n ch∆∞a ho√†n th√†nh - t·ª± ƒë·ªông h·ªßy ƒë∆°n v√† hi·ªÉn th·ªã modal nh∆∞ c≈©
                    await this.cancelOrder();
                }
            }



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































            
                        
            // X·ª≠ l√Ω khi qu√©t ƒë∆°n kh√°c (KH√îNG cho ph√©p chuy·ªÉn)
            async handleDifferentOrderBlocked(newMaVanDon) {
                // Hi·ªÉn th·ªã th√¥ng b√°o kh√¥ng cho ph√©p chuy·ªÉn ƒë∆°n
                this.showWarning(
                    `Kh√¥ng th·ªÉ chuy·ªÉn sang ƒë∆°n ${newMaVanDon}.`,
                    `ƒêang x·ª≠ l√Ω ƒë∆°n ${this.currentOrder.maVanDon}. Vui l√≤ng ho√†n th√†nh ƒë∆°n hi·ªán t·∫°i tr∆∞·ªõc khi chuy·ªÉn ƒë∆°n kh√°c.\n\nH∆∞·ªõng d·∫´n:\n‚Ä¢ Qu√©t l·∫°i ƒë∆°n ${this.currentOrder.maVanDon} ƒë·ªÉ ho√†n th√†nh\n‚Ä¢ Ho·∫∑c qu√©t l·∫°i ƒë∆°n ${this.currentOrder.maVanDon} ƒë·ªÉ h·ªßy`
                );
                
                // Focus l·∫°i input ƒë·ªÉ ti·∫øp t·ª•c qu√©t m√£ h√†ng c·ªßa ƒë∆°n hi·ªán t·∫°i
                this.ensureInputFocus();
            }
            
            // X·ª≠ l√Ω ƒë∆°n kh√°c (checkout ƒë∆°n hi·ªán t·∫°i v√† checkin ƒë∆°n m·ªõi) - KH√îNG C√íN S·ª¨ D·ª§NG
            async handleDifferentOrder(newMaVanDon) {
                // ƒê√≥ng modal n·∫øu ƒëang hi·ªÉn th·ªã
                hideModal();
                
                // L∆∞u th√¥ng tin ƒë∆°n hi·ªán t·∫°i
                const oldMaVanDon = this.currentOrder?.maVanDon;
                
                // 1. Ki·ªÉm tra xem ƒë∆°n m·ªõi c√≥ t·ªìn t·∫°i kh√¥ng tr∆∞·ªõc khi rollback ƒë∆°n c≈©
                const response = await fetch(`/api/orders/by-van-don/${encodeURIComponent(newMaVanDon)}`, {
                    credentials: 'include',
                    headers: { 'Authorization': 'Bearer ' + getAuthToken() }
                });
                const result = await response.json();
                
                if (!result.success) {
                    // N·∫øu ƒë∆°n m·ªõi kh√¥ng t·ªìn t·∫°i, kh√¥ng rollback ƒë∆°n c≈© - ch·ªâ hi·ªÉn th·ªã l·ªói v√† gi·ªØ nguy√™n tr·∫°ng th√°i
                    if (result.message && result.message.includes('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n n√†y')) {
                        this.showError(`Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n ${newMaVanDon}. Ti·∫øp t·ª•c qu√©t ƒë∆°n hi·ªán t·∫°i ${oldMaVanDon}.`);
                        return;
                    }
                    // C√°c l·ªói kh√°c (v√≠ d·ª•: ƒë∆°n ƒë√£ ho√†n th√†nh)
                    if (result.message && result.message.includes('ƒë√£ ƒë∆∞·ª£c qu√©t ho√†n t·∫•t')) {
                        this.showWarning(`ƒê∆°n ${newMaVanDon} ƒë√£ ƒë∆∞·ª£c qu√©t ho√†n t·∫•t. Ti·∫øp t·ª•c qu√©t ƒë∆°n hi·ªán t·∫°i ${oldMaVanDon}.`);
                        return;
                    }
                    // L·ªói kh√°c
                    this.showError(`L·ªói t·∫£i ƒë∆°n ${newMaVanDon}: ${result.message}. Ti·∫øp t·ª•c qu√©t ƒë∆°n hi·ªán t·∫°i ${oldMaVanDon}.`);
                    return;
                }
                
                // 2. N·∫øu ƒë∆°n m·ªõi t·ªìn t·∫°i, rollback ƒë∆°n hi·ªán t·∫°i (checkout)
                try {
                    await this.rollbackCurrentOrder();
                } catch (error) {
                    // Ignore rollback errors
                }
                
                // 3. Reset state
                this.reset();
                
                // 4. Check-in ƒë∆°n m·ªõi
                await this.checkinOrder(newMaVanDon);
            }
            
            // Hi·ªÉn th·ªã modal x√°c nh·∫≠n chuy·ªÉn ƒë∆°n (kh√¥ng c√≤n s·ª≠ d·ª•ng)
            async showSwitchConfirmation(newMaVanDon) {
                // Logic n√†y kh√¥ng c√≤n s·ª≠ d·ª•ng v√¨ ch·ªâ cho ph√©p chuy·ªÉn ƒë∆°n sau checkout
                this.showError('Vui l√≤ng checkout ƒë∆°n hi·ªán t·∫°i tr∆∞·ªõc khi chuy·ªÉn ƒë∆°n kh√°c.');
            }
            
            // Chuy·ªÉn sang ƒë∆°n m·ªõi (sau khi checkout)
            async switchToNewOrder(newMaVanDon) {
                try {
                    // Check-in ƒë∆°n m·ªõi (ƒë√£ checkout r·ªìi n√™n kh√¥ng c·∫ßn rollback)
                    await this.checkinOrder(newMaVanDon);
                    
                } catch (error) {
                    throw new Error(`L·ªói chuy·ªÉn ƒë∆°n: ${error.message}`);
                }
            }
            
            // Rollback ƒë∆°n hi·ªán t·∫°i
            async rollbackCurrentOrder() {
                try {
                    if (!this.currentOrder) return;
                    
                    const maVanDon = this.currentOrder.maVanDon;
                    
                    // Unblock ƒë∆°n tr√™n server
                    await fetch('/api/orders/unblock-van-don', {
                        method: 'POST',
                        credentials: 'include',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + getAuthToken()
                        },
                        body: JSON.stringify({ maVanDon })
                    });
                    
                } catch (error) {
                    // Kh√¥ng throw error v√¨ rollback kh√¥ng ph·∫£i l·ªói nghi√™m tr·ªçng
                }
            }
            
            // Check-in ƒë∆°n h√†ng
            async checkinOrder(maVanDon) {
                try {
                    
                    // Load ƒë∆°n h√†ng t·ª´ server
                    const response = await fetch(`/api/orders/by-van-don/${encodeURIComponent(maVanDon)}`, {
                        credentials: 'include',
                        headers: { 'Authorization': 'Bearer ' + getAuthToken() }
                    });
                    const result = await response.json();
                    
                    if (!result.success) {
                        // Ki·ªÉm tra n·∫øu ƒë∆°n ƒë√£ ho√†n th√†nh
                        if (result.message && result.message.includes('ƒë√£ ƒë∆∞·ª£c qu√©t ho√†n t·∫•t')) {
                            this.showWarning(`ƒê∆°n ${maVanDon} ƒë√£ ƒë∆∞·ª£c qu√©t ho√†n t·∫•t. Vui l√≤ng ch·ªçn ƒë∆°n kh√°c.`);
                            return;
                        }
                        
                        // Ki·ªÉm tra n·∫øu kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng - kh√¥ng rollback, ch·ªâ hi·ªÉn th·ªã l·ªói
                        if (result.message && result.message.includes('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n n√†y')) {
                            this.showError(`Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n ${maVanDon}. Vui l√≤ng ki·ªÉm tra l·∫°i m√£ v·∫≠n ƒë∆°n.`);
                            return;
                        }
                        
                        throw new Error(result.message || 'Kh√¥ng th·ªÉ t·∫£i ƒë∆°n h√†ng');
                    }
                    
                    // C·∫≠p nh·∫≠t state
                    this.currentOrder = { maVanDon, ...result.data };
                    this.cacheOrders = result.data.orders || [];
                    this.scannedItems = [];
                    this.state = CheckStates.ORDER_ACTIVE;
                    
                    // C·∫≠p nh·∫≠t UI
                    this.updateUI();
                    
                    // Hi·ªÉn th·ªã th√¥ng b√°o ng·∫Øn g·ªçn
                    const verifiedCount = result.data.alreadyVerifiedItems?.length || 0;
                    this.showInfo(`ƒê√£ check-in ${this.cacheOrders.length} m·∫∑t h√†ng cho ƒë∆°n ${maVanDon}. B·∫Øt ƒë·∫ßu qu√©t h√†ng.`);
                    
                    // L∆∞u user behaviour
                    await this.saveUserBehaviour('scanner', `Check-in ƒë∆°n h√†ng: ${maVanDon} - ${this.cacheOrders.length} m·∫∑t h√†ng`, {
                        maVanDon: maVanDon,
                        orderCount: this.cacheOrders.length,
                        verifiedItemsCount: verifiedCount,
                        action: 'checkin_order'
                    });
                    
                    // ƒê·∫£m b·∫£o reset loading state sau khi ho√†n th√†nh
                    this.isLoading = false;
                    
                } catch (error) {
                    // ƒê·∫£m b·∫£o reset loading state khi c√≥ l·ªói
                    this.isLoading = false;
                    
                    // Ki·ªÉm tra n·∫øu l·ªói l√† "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n n√†y" - kh√¥ng rollback, ch·ªâ hi·ªÉn th·ªã l·ªói
                    if (error.message && error.message.includes('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n n√†y')) {
                        this.showError(`Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n ${maVanDon}. Vui l√≤ng ki·ªÉm tra l·∫°i m√£ v·∫≠n ƒë∆°n.`);
                        return;
                    }
                    
                    throw new Error(`L·ªói check-in ƒë∆°n: ${error.message}`);
                }
            }
            
            // Check-out ƒë∆°n h√†ng (hi·ªÉn th·ªã modal x√°c nh·∫≠n)
            async handleCheckout() {
                
                const uniqueProducts = new Set(this.scannedItems.map(item => item.maHang));
                const scannedCount = Array.from(uniqueProducts).reduce((sum, maHang) => {
                    const scannedItemsForThisProduct = this.scannedItems.filter(item => item.maHang === maHang);
                    if (scannedItemsForThisProduct.length > 0) {
                        const latestItem = scannedItemsForThisProduct[scannedItemsForThisProduct.length - 1];
                        return sum + (latestItem.soLuongDaQuet || 0);
                    }
                    return sum;
                }, 0);
                const totalRequired = this.cacheOrders.reduce((sum, order) => sum + order.soLuong, 0);
                const isCompleted = scannedCount >= totalRequired;
                
                this.showModal({
                    type: 'info',
                    title: 'Check-out ƒë∆°n h√†ng',
                    message: `ƒê∆°n ${this.currentOrder.maVanDon} ƒë√£ qu√©t ${scannedCount}/${totalRequired} m√£ h√†ng${isCompleted ? ' (Ho√†n th√†nh)' : ' (Ch∆∞a ho√†n th√†nh)'}.\n\nH∆∞·ªõng d·∫´n:\n‚Ä¢ Qu√©t ƒë∆°n kh√°c ƒë·ªÉ chuy·ªÉn ƒë∆°n\n‚Ä¢ Nh·∫•n Enter ƒë·ªÉ x√°c nh·∫≠n checkout`,
                    buttons: [
                        {
                            text: 'X√°c nh·∫≠n checkout',
                            class: 'primary',
                            onclick: () => {
                                this.reset();
                                this.showInfo(`ƒê√£ checkout ƒë∆°n ${this.currentOrder?.maVanDon || 'hi·ªán t·∫°i'}. S·∫µn s√†ng qu√©t ƒë∆°n m·ªõi.`);
                            }
                        }
                    ]
                });
            }
            
            // Qu√©t m√£ h√†ng
            async scanItem(maHang) {
                try {
                    
                    // Ki·ªÉm tra m√£ h√†ng c√≥ trong danh s√°ch ƒë∆°n h√†ng kh√¥ng
                    const orderItem = this.cacheOrders.find(order => order.maHang === maHang);
                    if (!orderItem) {
                        this.showError(`M√£ h√†ng ${maHang} kh√¥ng c√≥ trong ƒë∆°n h√†ng hi·ªán t·∫°i!`);
                        this.isLoading = false;
                        return;
                    }
                    
                    // Ki·ªÉm tra ƒë√£ qu√©t ƒë·ªß ch∆∞a
                    const scannedItemsForThisProduct = this.scannedItems.filter(item => item.maHang === maHang);
                    const currentScanned = scannedItemsForThisProduct.length;
                    const required = orderItem.soLuong;
                    
                    if (currentScanned >= required) {
                        this.showError(`M√£ h√†ng ${maHang} ƒë√£ qu√©t ƒë·ªß (${currentScanned}/${required})! Kh√¥ng th·ªÉ qu√©t th√™m.`);
                        this.isLoading = false;
                        return;
                    }
                    
                    const response = await fetch('/api/orders/scan', {
                        credentials: 'include',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + getAuthToken()
                        },
                        body: JSON.stringify({ 
                            maVanDon: this.currentOrder.maVanDon, 
                            maHang 
                        })
                    });
                    const result = await response.json();
                    
                    if (!result.success) {
                        // Ki·ªÉm tra n·∫øu kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng - kh√¥ng rollback, ch·ªâ hi·ªÉn th·ªã l·ªói v√† ti·∫øp t·ª•c qu√©t
                        if (result.message && result.message.includes('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n n√†y')) {
                            this.showError(`Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n ${this.currentOrder.maVanDon}. Vui l√≤ng ki·ªÉm tra l·∫°i m√£ v·∫≠n ƒë∆°n.`);
                            // Kh√¥ng throw error ƒë·ªÉ kh√¥ng rollback, gi·ªØ nguy√™n tr·∫°ng th√°i ƒë∆°n hi·ªán t·∫°i
                            this.isLoading = false;
                            return;
                        }
                        
                        throw new Error(result.message || 'Qu√©t kh√¥ng th√†nh c√¥ng');
                    }
                    
                    // Th√™m v√†o danh s√°ch ƒë√£ qu√©t (tƒÉng s·ªë l∆∞·ª£ng ƒë√£ qu√©t l√™n 1)
                    const newScanned = currentScanned + 1;
                    this.scannedItems.push({
                        maHang: result.data.maHang,
                        timestamp: new Date(),
                        soLuongDaQuet: newScanned, // TƒÉng s·ªë l∆∞·ª£ng ƒë√£ qu√©t l√™n 1
                        soLuongYeuCau: required, // S·ªë l∆∞·ª£ng c·∫ßn qu√©t
                        isCombo: result.data.isCombo
                    });
                    
                    // C·∫≠p nh·∫≠t UI ngay l·∫≠p t·ª©c
                    this.updateUI();
                    
                    // Hi·ªÉn th·ªã th√¥ng b√°o qu√©t th√†nh c√¥ng
                    this.showInfo(`‚úÖ ƒê√£ qu√©t: ${result.data.maHang} (${newScanned}/${required})`);
                    
                    // L∆∞u user behaviour
                    await this.saveUserBehaviour('scanner', `Qu√©t m√£ h√†ng: ${result.data.maHang} - Ti·∫øn ƒë·ªô: ${newScanned}/${required}`, {
                        maVanDon: this.currentOrder.maVanDon,
                        maHang: result.data.maHang,
                        originalMaHang: result.data.originalMaHang,
                        scannedQuantity: newScanned,
                        requiredQuantity: required,
                        verified: result.data.verified,
                        isCombo: result.data.isCombo,
                        action: 'scan_item'
                    });
                    
                    // Ki·ªÉm tra ƒë∆°n c√≥ ho√†n th√†nh kh√¥ng
                    if (this.isOrderCompletedSync()) {
                        this.state = CheckStates.ORDER_COMPLETED;
                        await this.showCompletionModal();
                    } else {
                        this.state = CheckStates.SCANNING;
                        // T·ª± ƒë·ªông ti·∫øp t·ª•c qu√©t, kh√¥ng hi·ªÉn th·ªã modal
                        this.showInfo(`Ti·∫øp t·ª•c qu√©t ƒë∆°n ${this.currentOrder.maVanDon}`);
                    }
                    
                    // ƒê·∫£m b·∫£o reset loading state sau khi ho√†n th√†nh
                    this.isLoading = false;
                    
                } catch (error) {
                    // Ki·ªÉm tra n·∫øu l·ªói l√† "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n n√†y" - kh√¥ng rollback, ch·ªâ hi·ªÉn th·ªã l·ªói
                    if (error.message && error.message.includes('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n n√†y')) {
                        this.showError(`Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi m√£ v·∫≠n ƒë∆°n ${this.currentOrder.maVanDon}. Ti·∫øp t·ª•c qu√©t ƒë∆°n hi·ªán t·∫°i.`);
                        this.isLoading = false;
                        return;
                    }
                    
                    // C√°c l·ªói kh√°c - hi·ªÉn th·ªã l·ªói nh∆∞ng kh√¥ng rollback ƒë∆°n hi·ªán t·∫°i
                    this.showError(`L·ªói qu√©t m√£ h√†ng: ${error.message}. Ti·∫øp t·ª•c qu√©t ƒë∆°n hi·ªán t·∫°i ${this.currentOrder.maVanDon}.`);
                    this.isLoading = false;
                }
            }
            
            // Hi·ªÉn th·ªã modal ho√†n th√†nh ƒë∆°n (t·ª± ƒë·ªông ho√†n th√†nh)
            async showCompletionModal() {
                // T·ª± ƒë·ªông ho√†n th√†nh ƒë∆°n thay v√¨ hi·ªÉn th·ªã modal
                try {
                    await this.completeOrder();
                } catch (error) {
                    this.showError(`L·ªói ho√†n th√†nh ƒë∆°n: ${error.message}`);
                }
                
                return Promise.resolve();
            }
            
            // Hi·ªÉn th·ªã modal ti·∫øp t·ª•c qu√©t (kh√¥ng c√≤n s·ª≠ d·ª•ng)
            async showContinueModal() {
                // Kh√¥ng c√≤n s·ª≠ d·ª•ng modal n√†y, t·ª± ƒë·ªông ti·∫øp t·ª•c qu√©t
                return Promise.resolve();
            }
            
            // H·ªßy ƒë∆°n h√†ng
            async cancelOrder() {
                try {
                    const orderToCancel = this.currentOrder.maVanDon;
                    
                    // L∆∞u UserBehaviour tr∆∞·ªõc khi rollback
                    await this.saveUserBehaviour('scanner', `H·ªßy ƒë∆°n ${orderToCancel}`, {
                        maVanDon: orderToCancel,
                        action: 'cancel_order',
                        missingItems: checkMissingItems()
                    });
                    
                    // Rollback ƒë∆°n tr√™n server
                    await this.rollbackCurrentOrder();
                    
                    // Reset state
                    this.reset();
                    
                    // Hi·ªÉn th·ªã modal th√¥ng b√°o h·ªßy ƒë∆°n
                    this.showModal({
                        type: 'warning',
                        title: 'ƒê√£ h·ªßy ƒë∆°n h√†ng',
                        message: `ƒê∆°n ${orderToCancel} ƒë√£ ƒë∆∞·ª£c h·ªßy th√†nh c√¥ng.\n\nS·∫µn s√†ng qu√©t ƒë∆°n m·ªõi.`,
                        timeout: 2000
                    });
                    
                    // Sau 2 gi√¢y, v·ªÅ trang check ƒë∆°n r·ªóng
                    setTimeout(() => {
                        this.showInfo('S·∫µn s√†ng qu√©t ƒë∆°n m·ªõi');
                    }, 2000);
                    
                } catch (error) {
                    this.showError(`L·ªói h·ªßy ƒë∆°n: ${error.message}`);
                }
            }
            
            // Ho√†n th√†nh ƒë∆°n h√†ng
            async completeOrder() {
                try {
                    const response = await fetch('/api/orders/complete-van-don', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + getAuthToken()
                        },
                        body: JSON.stringify({
                            maVanDon: this.currentOrder.maVanDon
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        const completedOrder = this.currentOrder.maVanDon;
                        
                        // Reset state tr∆∞·ªõc
                        this.reset();
                        
                        // Hi·ªÉn th·ªã modal th√¥ng b√°o ho√†n th√†nh
                        this.showModal({
                            type: 'success',
                            title: 'ƒê∆°n h√†ng ho√†n t·∫•t',
                            message: `ƒê∆°n ${completedOrder} ƒë√£ ƒë∆∞·ª£c qu√©t ho√†n t·∫•t th√†nh c√¥ng.\n\nS·∫µn s√†ng qu√©t ƒë∆°n m·ªõi.`,
                            timeout: 2000
                        });
                        
                        // Sau 2 gi√¢y, v·ªÅ trang check ƒë∆°n r·ªóng
                        setTimeout(() => {
                            this.showInfo('S·∫µn s√†ng qu√©t ƒë∆°n m·ªõi');
                        }, 2000);
                        
                    } else {
                        throw new Error(result.message);
                    }
                    
                } catch (error) {
                    throw new Error(`L·ªói ho√†n th√†nh ƒë∆°n: ${error.message}`);
                }
            }
            
            // Reset state machine
            reset() {
                // Unblock ƒë∆°n hi·ªán t·∫°i n·∫øu c√≥
                if (this.currentOrder) {
                    this.rollbackCurrentOrder().catch(error => {
                        // Ignore rollback errors during reset
                    });
                }
                
                // Reset state
                this.state = CheckStates.IDLE;
                this.currentOrder = null;
                this.scannedItems = [];
                this.cacheOrders = [];
                
                // C·∫≠p nh·∫≠t UI
                this.updateUI();
                
                // ƒê·∫£m b·∫£o input ƒë∆∞·ª£c focus ƒë·ªÉ s·∫µn s√†ng qu√©t ti·∫øp
                this.ensureInputFocus();
            }
            
            // C·∫≠p nh·∫≠t UI
            updateUI() {
                // C·∫≠p nh·∫≠t currentMaVanDon global
                currentMaVanDon = this.currentOrder?.maVanDon || '';
                cacheOrders = this.cacheOrders;
                scannedItems = [...this.scannedItems]; // Copy array ƒë·ªÉ ƒë·ªìng b·ªô
                orderCheckState = this.state;
                
                // C·∫≠p nh·∫≠t DOM
                document.getElementById('maVanDonTag').textContent = currentMaVanDon || 'Ch∆∞a ch·ªçn';
                renderQueue();
                renderOrders();
                updateProgress();
            }
            
            // Hi·ªÉn th·ªã l·ªói
            showError(message) {
                setStatus(message, 'err');
                this.showModal({
                    type: 'error',
                    title: 'L·ªói',
                    message: message,
                    buttons: [{
                        text: 'OK',
                        class: 'primary',
                        onclick: () => this.ensureInputFocus()
                    }]
                });
            }
            
            // Hi·ªÉn th·ªã c·∫£nh b√°o
            showWarning(message) {
                setStatus(message, 'warn');
                this.showModal({
                    type: 'warning',
                    title: 'C·∫£nh b√°o',
                    message: message,
                    timeout: 3000
                });
            }
            
            // Hi·ªÉn th·ªã th√¥ng tin
            showInfo(message) {
                setStatus(message, 'info');
                // Kh√¥ng hi·ªÉn th·ªã modal cho th√¥ng tin, ch·ªâ update status
                // Auto hide sau 3 gi√¢y
                setTimeout(() => {
                    setStatus('', '');
                }, 3000);
            }
            
            // Hi·ªÉn th·ªã th√†nh c√¥ng
            showSuccess(title, message) {
                setStatus(message, 'ok');
                this.showModal({
                    type: 'success',
                    title: title,
                    message: message,
                    timeout: 2000
                });
            }
            
            // Hi·ªÉn th·ªã modal
            showModal(options) {
                // Implementation s·∫Ω s·ª≠ d·ª•ng h√†m showModal hi·ªán c√≥
                showModal(options);
            }
            
            // ƒê·∫£m b·∫£o input ƒë∆∞·ª£c focus
            ensureInputFocus() {
                const input = document.getElementById('codeInput');
                if (input) {
                    input.value = '';
                    input.focus();
                    input.click();
                    
                    // Th√™m visual feedback
                    input.style.borderColor = '#667eea';
                    setTimeout(() => {
                        input.style.borderColor = '';
                    }, 1000);
                }
            }
            
            // L∆∞u user behaviour
            async saveUserBehaviour(method, description, metadata = {}) {
                try {
                    const response = await fetch('/api/user-behaviour', {
                        method: 'POST',
                        credentials: 'include',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + getAuthToken()
                        },
                        body: JSON.stringify({
                            method,
                            description,
                            metadata
                        })
                    });
                    
                    const result = await response.json();
                    if (!result.success) {
                    }
                } catch (error) {
                }
            }
        }
        
        // Kh·ªüi t·∫°o State Machine
        const orderCheckSM = new OrderCheckStateMachine();
        
        // H√†m ki·ªÉm tra thi·∫øu h√†ng
        function checkMissingItems() {
            const missingItems = [];
            const currentScannedItems = orderCheckSM.scannedItems || scannedItems;
            cacheOrders.forEach(order => {
                const scannedItemsForThisProduct = currentScannedItems.filter(item => item.maHang === order.maHang);
                let scannedQty = 0;
                
                if (scannedItemsForThisProduct.length > 0) {
                    const latestItem = scannedItemsForThisProduct[scannedItemsForThisProduct.length - 1];
                    scannedQty = latestItem.soLuongDaQuet || 0;
                }
                
                if (scannedQty < order.soLuong) {
                    missingItems.push({
                        maHang: order.maHang,
                        soLuongYeuCau: order.soLuong,
                        soLuongDaQuet: scannedQty,
                        soLuongThieu: order.soLuong - scannedQty
                    });
                }
            });
            return missingItems;
        }
        
        // H√†m hi·ªÉn th·ªã modal thi·∫øu h√†ng
        function showMissingItemsModal(missingItems) {
            let message = 'ƒê∆°n h√†ng b·ªã thi·∫øu c√°c m·∫∑t h√†ng sau:\n\n';
            missingItems.forEach(item => {
                message += `‚Ä¢ M√£ h√†ng: ${item.maHang}\n`;
                message += `  Y√™u c·∫ßu: ${item.soLuongYeuCau}\n`;
                message += `  ƒê√£ qu√©t: ${item.soLuongDaQuet}\n`;
                message += `  Thi·∫øu: ${item.soLuongThieu}\n\n`;
            });
            message += 'Ch·ªçn h√†nh ƒë·ªông ti·∫øp theo:';
            
            showModal({
                type: 'warning',
                title: 'ƒê∆°n h√†ng b·ªã thi·∫øu h√†ng',
                message: message,
                buttons: [
                    {
                        text: 'Qu√©t l·∫°i ƒë∆°n',
                        class: 'primary',
                        onclick: () => {
                            orderCheckState = 'scanning';
                            scannedItems = [];
                            setStatus('ƒê√£ reset. H√£y qu√©t l·∫°i m√£ v·∫≠n ƒë∆°n ƒë·ªÉ ti·∫øp t·ª•c.', 'ok');
                            ensureInputFocus();
                        }
                    },
                    {
                        text: 'Qu√©t ƒë∆°n kh√°c',
                        class: 'secondary',
                        onclick: () => {
                            orderCheckState = 'idle';
                            scannedItems = [];
                            currentMaVanDon = '';
                            setCacheOrders([], 'reset-after-complete');
                            currentVanDonStatus = null;
                            waitingForNewOrder = false;
                            document.getElementById('maVanDonTag').textContent = 'Ch∆∞a ch·ªçn';
                            setStatus('ƒê√£ h·ªßy ƒë∆°n hi·ªán t·∫°i. H√£y nh·∫≠p m√£ v·∫≠n ƒë∆°n m·ªõi.', 'info');
                            ensureInputFocus();
                            renderQueue();
                            renderOrders();
                        }
                    }
                ]
            });
        }

        async function ensureChecker() {
            // Robust check that tolerates browser cookie timing and per-tab JWT races.
            // Strategy:
            // 1) Try cookie+Authorization (if token present).
            // 2) If that fails and a token exists, try token-only.
            // 3) Retry with exponential backoff (both cookie+token and token-only) for a short window.
            // 4) Before final redirect, give a last short wait to allow Set-Cookie to apply in the browser.
            try {
                let data = null;
                const tryOnce = async (useCredentials, token) => {
                    const headers = {};
                    if (token) headers['Authorization'] = 'Bearer ' + token;
                    try {
                        const res = await fetch('/api/me', useCredentials ? { credentials: 'include', headers } : { headers });
                        return await res.json();
                    } catch (e) {
                        return null;
                    }
                };

                const token = getAuthToken();
                // 1) Immediate attempt: credentials + token (if any)
                data = await tryOnce(true, token);

                // 2) If that didn't work and we have a token, try token-only immediately
                if ((!data || !data.success) && token) {
                    const tdata = await tryOnce(false, token);
                    if (tdata && tdata.success) data = tdata;
                }

                // 3) Retry loop with exponential backoff (total ~1s)
                const backoffs = [150, 200, 300, 400]; // ms
                for (let i = 0; (!data || !data.success) && i < backoffs.length; i++) {
                    await new Promise(r => setTimeout(r, backoffs[i]));
                    const tkn = getAuthToken();
                    // prefer cookie+Authorization first
                    const d1 = await tryOnce(true, tkn);
                    if (d1 && d1.success) { data = d1; break; }
                    // then try token-only
                    if (tkn) {
                        const d2 = await tryOnce(false, tkn);
                        if (d2 && d2.success) { data = d2; break; }
                    }
                }

                // 4) Final short wait to let browser apply Set-Cookie (helps some browsers)
                if (!data || !data.success) {
                    await new Promise(r => setTimeout(r, 120));
                    const finalToken = getAuthToken();
                    const finalTry = await tryOnce(true, finalToken);
                    if (finalTry && finalTry.success) data = finalTry;
                    else if (finalToken) {
                        const finalTry2 = await tryOnce(false, finalToken);
                        if (finalTry2 && finalTry2.success) data = finalTry2;
                    }
                }

                if (!data || !data.success || !['checker','packer'].includes(data.role)) {
                    // No auth -> show overlay and redirect
                    showForbiddenOverlay();
                    setTimeout(() => { location.href = '/login'; }, 2200);
                    return false;
                }

                userRole = data.role;
                const roleName = data.role === 'packer' ? 'packer' : 'checker';
                document.getElementById('userTag').textContent = data.username + ' (' + roleName + ')';
                const titleRole = data.role === 'packer' ? 'Packer' : 'Checker';
                document.title = titleRole + ' - M·ªôt trang duy nh·∫•t';
                const h1 = document.querySelector('h1');
                if (h1) h1.textContent = titleRole;
                
                // T·∫°o text hi·ªÉn th·ªã t√™n user ·ªü g√≥c tr√™n b√™n ph·∫£i
                let userText = document.getElementById('userText');
                if (!userText) {
                    userText = document.createElement('div');
                    userText.id = 'userText';
                    userText.style.cssText = `
                        position: fixed;
                        top: 16px;
                        right: 140px;
                        color: #e2e8f0;
                        font-weight: 600;
                        font-size: 14px;
                        z-index: 1001;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        background: rgba(30, 41, 59, 0.9);
                        padding: 8px 12px;
                        border-radius: 8px;
                        backdrop-filter: blur(10px);
                        border: 1px solid rgba(71, 85, 105, 0.3);
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                    `;
                    userText.innerHTML = `
                        <span style="color: #3b82f6; font-size: 16px;">üë§</span>
                        <span id="headerUsername">${data.username}</span>
                        <span style="color: #94a3b8; font-size: 12px;">(${titleRole})</span>
                    `;
                    document.body.appendChild(userText);
                } else {
                    // C·∫≠p nh·∫≠t t√™n user n·∫øu ƒë√£ t·ªìn t·∫°i
                    const usernameSpan = document.getElementById('headerUsername');
                    if (usernameSpan) {
                        usernameSpan.textContent = data.username;
                    }
                }
                
                // T·∫°o n√∫t logout ·ªü g√≥c tr√™n b√™n ph·∫£i
                let logoutBtn = document.getElementById('headerLogoutBtn');
                if (!logoutBtn) {
                    logoutBtn = document.createElement('button');
                    logoutBtn.id = 'headerLogoutBtn';
                    logoutBtn.textContent = 'ƒêƒÉng xu·∫•t';
                    logoutBtn.style.cssText = `
                        position: fixed;
                        top: 16px;
                        right: 16px;
                        padding: 12px 24px;
                        font-size: 14px;
                        background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
                        border: none;
                        border-radius: 8px;
                        color: white;
                        cursor: pointer;
                        font-weight: 600;
                        transition: all 0.2s;
                        z-index: 1001;
                        box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3);
                        border: 1px solid rgba(185, 28, 28, 0.3);
                        min-height: 44px;
                        min-width: 100px;
                    `;
                    logoutBtn.onmouseover = function() {
                        this.style.transform = 'translateY(-1px)';
                        this.style.boxShadow = '0 4px 12px rgba(220, 38, 38, 0.4)';
                        this.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                    };
                    logoutBtn.onmouseout = function() {
                        this.style.transform = 'translateY(0)';
                        this.style.boxShadow = '0 2px 8px rgba(220, 38, 38, 0.3)';
                        this.style.background = 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)';
                    };
                    document.body.appendChild(logoutBtn);
                }
                
                // Hi·ªÉn th·ªã c·∫£ text v√† button
                userText.style.display = 'flex';
                logoutBtn.style.display = 'block';
                
                // Th√™m event listener cho n√∫t logout
                const headerLogoutBtn = document.getElementById('headerLogoutBtn');
                if (headerLogoutBtn) {
                    headerLogoutBtn.onclick = async () => {
                        showConfirmModal(
                            'X√°c nh·∫≠n ƒëƒÉng xu·∫•t',
                            'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ƒëƒÉng xu·∫•t?\nƒê∆°n h√†ng hi·ªán t·∫°i s·∫Ω ƒë∆∞·ª£c m·ªü kh√≥a.',
                            async () => {
                                try {
                                    // G·ª≠i y√™u c·∫ßu m·ªü kh√≥a cho ƒë∆°n hi·ªán t·∫°i
                                    if (currentMaVanDon) {
                                        await fetch('/api/orders/unblock-van-don', {
                                            method: 'POST',
                                            credentials: 'include',
                                            headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + getAuthToken() },
                                            body: JSON.stringify({ maVanDon: currentMaVanDon })
                                        });
                                    }
                                } catch {}
                                
                                // ƒêƒÉng xu·∫•t
                                await fetch('/api/logout', { method: 'POST' });
                                window.location.href = '/login';
                            }
                        );
                    };
                }
                
                return true;
            } catch (e) {
                // In case of unexpected failure, redirect to login (safe fallback)
                location.href = '/login';
                return false;
            }
        }

        function setStatus(text, type = '') {
            const el = document.getElementById('status');
            el.className = 'status ' + (type || '');
            el.textContent = text || '';
        }

        // Modal functions
        function showModal(options) {
            const overlay = document.getElementById('modalOverlay');
            const modal = document.getElementById('modal');
            const icon = document.getElementById('modalIcon');
            const title = document.getElementById('modalTitle');
            const message = document.getElementById('modalMessage');
            const buttons = document.getElementById('modalButtons');
            
            if (!overlay || !modal) {
                return;
            }
            
            // Remove all color classes first
            modal.classList.remove('success', 'error', 'warning', 'info', 'question');
            
            // Add the appropriate color class based on type
            if (options.type) {
                modal.classList.add(options.type);
            }
            
            // Lu√¥n ·∫©n icon
            icon.style.display = 'none';
            
            // Set title
            title.textContent = options.title || '';
            
            // Set message
            message.textContent = options.message || '';
            
            // Set buttons (·∫©n n√∫t n·∫øu c√≥ timeout - t·ª± ƒë·ªông ƒë√≥ng)
            buttons.innerHTML = '';
            if (options.timeout) {
                buttons.style.display = 'none';
            } else {
                buttons.style.display = 'flex';
                if (options.buttons) {
                    options.buttons.forEach(btn => {
                        const button = document.createElement('button');
                        button.textContent = btn.text;
                        button.className = `modal-btn ${btn.class || 'primary'}`;
                        button.onclick = () => {
                            if (btn.onclick) {
                                btn.onclick();
                            }
                            hideModal();
                        };
                        buttons.appendChild(button);
                    });
                } else {
                    // Default OK button
                    const okBtn = document.createElement('button');
                    okBtn.textContent = 'OK';
                    okBtn.className = 'modal-btn primary';
                    okBtn.onclick = hideModal;
                    buttons.appendChild(okBtn);
                }
            }
            
            // Add compact class if has timeout (no icon, no buttons)
            const modalElement = overlay.querySelector('.modal');
            if (options.timeout) {
                modalElement.classList.add('compact');
            } else {
                modalElement.classList.remove('compact');
            }
            
            // Show modal
            overlay.classList.add('show');
            
            // Auto hide after timeout if specified
            if (options.timeout) {
                setTimeout(hideModal, options.timeout);
            }
        }
        
        function hideModal() {
            const overlay = document.getElementById('modalOverlay');
            overlay.classList.remove('show');
            // ƒê·∫£m b·∫£o input ƒë∆∞·ª£c focus sau khi ƒë√≥ng modal
            setTimeout(ensureInputFocus, 100);
        }

        // Function ƒë·∫£m b·∫£o input lu√¥n ƒë∆∞·ª£c focus
        function ensureInputFocus() {
            const input = document.getElementById('codeInput');
            if (input) {
                // Clear value tr∆∞·ªõc khi focus
                input.value = '';
                // Focus v√† click ƒë·ªÉ ƒë·∫£m b·∫£o s·∫µn s√†ng nh·∫≠n input
                input.focus();
                input.click();
                // ƒê·∫£m b·∫£o cursor ·ªü cu·ªëi input
                setTimeout(() => {
                    input.setSelectionRange(0, 0);
                }, 10);
            }
        }


        
        // Convenience functions for different modal types
        function showSuccessModal(title, message, timeout = null) {
            showModal({
                type: 'success',
                title: title,
                message: message,
                timeout: timeout
            });
        }
        
        function showErrorModal(title, message) {
            showModal({
                type: 'error',
                title: title,
                message: message
            });
        }
        
        function showWarningModal(title, message) {
            showModal({
                type: 'warning',
                title: title,
                message: message
            });
        }
        
        function showConfirmModal(title, message, onConfirm, onCancel = null) {
            showModal({
                type: 'question',
                title: title,
                message: message,
                buttons: [
                    {
                        text: 'H·ªßy',
                        class: 'secondary',
                        onclick: onCancel
                    },
                    {
                        text: 'X√°c nh·∫≠n',
                        class: 'danger',
                        onclick: onConfirm
                    }
                ]
            });
        }
        
        // Close modal when clicking overlay
        document.getElementById('modalOverlay').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                hideModal();
            }
        });

        function renderQueue() {
            const el = document.getElementById('queue');
            if (!el) return;
            el.innerHTML = '';
            
            // Ch·ªâ hi·ªÉn th·ªã ƒë∆°n hi·ªán t·∫°i (kh√¥ng c√≤n queue n·ªØa)
            if (currentMaVanDon) {
                const currentScannedItems = orderCheckSM.scannedItems || scannedItems;
                const uniqueProducts = new Set(currentScannedItems.map(item => item.maHang));
                const scannedCount = Array.from(uniqueProducts).reduce((sum, maHang) => {
                    const scannedItemsForThisProduct = currentScannedItems.filter(item => item.maHang === maHang);
                    if (scannedItemsForThisProduct.length > 0) {
                        const latestItem = scannedItemsForThisProduct[scannedItemsForThisProduct.length - 1];
                        return sum + (latestItem.soLuongDaQuet || 0);
                    }
                    return sum;
                }, 0);
                const totalRequired = cacheOrders.reduce((sum, order) => sum + order.soLuong, 0);
                const isDone = orderCheckState === 'completed';
                // const isConfirming = orderCheckState === 'confirming'; // Kh√¥ng c√≤n c·∫ßn thi·∫øt
                
                const item = document.createElement('span');
                let statusClass = 'pending';
                let statusText = '';
                
                // Ki·ªÉm tra tr·∫°ng th√°i qu√©t
                if (orderCheckState === 'scanning') {
                    statusClass = 'processing';
                    statusText = ' (ƒêang x·ª≠ l√Ω)';
                } else if (orderCheckState === 'completed') {
                    statusClass = 'completed';
                    statusText = ' (Ho√†n th√†nh)';
                } else {
                    statusClass = 'pending';
                    statusText = ' (Ch∆∞a x·ª≠ l√Ω)';
                }
                
                item.className = `qitem ${statusClass} active`;
                const text = document.createElement('span');
                text.className = 'qtext';
                text.textContent = `${currentMaVanDon} (${scannedCount}/${totalRequired})${statusText}`;
                text.onclick = () => {
                    let statusMsg = '';
                    if (orderCheckState === 'completed') {
                        statusMsg = `ƒê∆°n ${currentMaVanDon} ƒë√£ ho√†n th√†nh`;
                    } else if (orderCheckState === 'scanning') {
                        statusMsg = `ƒêang x·ª≠ l√Ω ƒë∆°n ${currentMaVanDon}`;
                    } else {
                        statusMsg = `ƒê∆°n ${currentMaVanDon} ch∆∞a x·ª≠ l√Ω`;
                    }
                    setStatus(statusMsg, '');
                };
                const btn = document.createElement('button');
                btn.className = 'qbtn';
                btn.textContent = 'H·ªßy';
                btn.title = 'H·ªßy ƒë∆°n hi·ªán t·∫°i (m·ªü kh√≥a)';
                btn.onclick = async (e) => {
                    e.stopPropagation();
                    try {
                        // L∆∞u UserBehaviour tr∆∞·ªõc khi h·ªßy ƒë∆°n
                        const missingItems = checkMissingItems();
                        await fetch('/api/user-behaviour', {
                            method: 'POST',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + getAuthToken() },
                            body: JSON.stringify({
                                method: 'scanner',
                                description: `H·ªßy ƒë∆°n ${currentMaVanDon}`,
                                metadata: {
                                    maVanDon: currentMaVanDon,
                                    action: 'cancel_order',
                                    missingItems: missingItems
                                }
                            })
                        });
                        
                        await fetch('/api/orders/unblock-van-don', {
                            method: 'POST',
                            credentials: 'include',
                            headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + getAuthToken() },
                            body: JSON.stringify({ maVanDon: currentMaVanDon })
                        });
                        
                        // T·ª± ƒë·ªông refresh n·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô view
                        autoRefreshIfInViewMode();
                    } catch {}
                    
                    // Reset v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
                    const oldMaVanDon = currentMaVanDon;
                    currentMaVanDon = '';
                    setCacheOrders([], 'reset-after-cancel');
                    orderCheckState = 'idle';
                    scannedItems = [];
                    currentVanDonStatus = null;
                    document.getElementById('maVanDonTag').textContent = 'Ch∆∞a ch·ªçn';
                    renderQueue();
                    renderOrders();
                    setStatus(`ƒê√£ h·ªßy ƒë∆°n ${oldMaVanDon}`, 'ok');
                    ensureInputFocus();
                };
                item.appendChild(text);
                item.appendChild(btn);
                el.appendChild(item);
            }
        }

        function renderOrders() {
            
            const body = document.getElementById('rows');
            if (!body) {
                return;
            }
            
            body.innerHTML = '';
            
            // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô check, ch·ªâ hi·ªÉn th·ªã khi c√≥ ƒë∆°n h√†ng ƒë∆∞·ª£c ch·ªçn
            if (activeView === 'check') {
                // N·∫øu kh√¥ng c√≥ ƒë∆°n h√†ng ƒë∆∞·ª£c ch·ªçn ho·∫∑c kh√¥ng c√≥ cacheOrders, kh√¥ng hi·ªÉn th·ªã g√¨
                if (!currentMaVanDon || !cacheOrders || !Array.isArray(cacheOrders) || cacheOrders.length === 0) {
                    return;
                }
                // N·∫øu c√≥ ƒë∆°n h√†ng, ti·∫øp t·ª•c hi·ªÉn th·ªã (kh√¥ng c√≥ search box)
            }
            
            // Th√™m search box cho ch·∫ø ƒë·ªô view
            if (activeView === 'view') {
                const searchContainer = document.createElement('div');
                searchContainer.style.cssText = `
                    background: #1e293b;
                    padding: 16px;
                    margin-bottom: 16px;
                    border-radius: 8px;
                    border: 1px solid #334155;
                `;
                
                searchContainer.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                        <label style="color: #e2e8f0; font-weight: 600; white-space: nowrap;">üîç T√¨m theo m√£ v·∫≠n ƒë∆°n:</label>
                        <input type="text" id="searchMaVanDon" placeholder="Nh·∫≠p m√£ v·∫≠n ƒë∆°n ƒë·ªÉ t√¨m ki·∫øm..." style="
                            flex: 1;
                            padding: 10px 12px;
                            border-radius: 6px;
                            border: 2px solid #475569;
                            background: #334155;
                            color: #e2e8f0;
                            font-size: 14px;
                            transition: all 0.2s;
                        " onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" 
                        onblur="this.style.borderColor='#475569'; this.style.boxShadow='none'">
                        <button id="searchBtn" style="
                            padding: 10px 20px;
                            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: 600;
                            font-size: 14px;
                            transition: all 0.2s;
                        " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(59, 130, 246, 0.4)'" 
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(59, 130, 246, 0.3)'">
                            T√¨m ki·∫øm
                        </button>
                        <button id="clearSearchBtn" style="
                            padding: 10px 20px;
                            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: 600;
                            font-size: 14px;
                            transition: all 0.2s;
                        " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(107, 114, 128, 0.4)'" 
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(107, 114, 128, 0.3)'">
                            X√≥a
                        </button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <label style="color: #e2e8f0; font-weight: 600; white-space: nowrap;">üìÖ T·ª´ ng√†y:</label>
                        <input type="date" id="dateFrom" style="
                            padding: 10px 12px;
                            border-radius: 6px;
                            border: 2px solid #475569;
                            background: #334155;
                            color: #e2e8f0;
                            font-size: 14px;
                            transition: all 0.2s;
                        " onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" 
                        onblur="this.style.borderColor='#475569'; this.style.boxShadow='none'">
                        <label style="color: #e2e8f0; font-weight: 600; white-space: nowrap;">ƒê·∫øn ng√†y:</label>
                        <input type="date" id="dateTo" style="
                            padding: 10px 12px;
                            border-radius: 6px;
                            border: 2px solid #475569;
                            background: #334155;
                            color: #e2e8f0;
                            font-size: 14px;
                            transition: all 0.2s;
                        " onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" 
                        onblur="this.style.borderColor='#475569'; this.style.boxShadow='none'">
                    </div>
                `;
                
                body.appendChild(searchContainer);
                
                // Th√™m event listeners cho search
                const searchInput = document.getElementById('searchMaVanDon');
                const searchBtn = document.getElementById('searchBtn');
                const clearSearchBtn = document.getElementById('clearSearchBtn');
                
                // Bi·∫øn ƒë·ªÉ qu·∫£n l√Ω request v√† debounce
                let currentSearchController = null;
                let searchTimeout = null;
                let searchPagination = { page: 1, pageSize: 20, total: 0, totalPages: 1 };
                
                const performSearch = async (page = 1) => {
                    // Cancel request c≈© n·∫øu c√≥
                    if (currentSearchController) {
                        currentSearchController.abort();
                        currentSearchController = null;
                    }
                    
                    // Clear timeout c≈© n·∫øu c√≥
                    if (searchTimeout) {
                        clearTimeout(searchTimeout);
                        searchTimeout = null;
                    }
                    // Kh√¥ng d·ª´ng polling khi t√¨m ki·∫øm - ƒë·ªÉ t·ª± ƒë·ªông refresh search results
                    const searchValue = searchInput.value.trim().toLowerCase();
                    const dateFrom = dateFromInput ? dateFromInput.value : '';
                    const dateTo = dateToInput ? dateToInput.value : '';
                    
                    // Clear danh s√°ch c≈© tr∆∞·ªõc khi t√¨m ki·∫øm
                    const body = document.getElementById('rows');
                    if (body) {
                        // X√≥a t·∫•t c·∫£ rows (tr·ª´ search box)
                        const existingRows = body.querySelectorAll('.row');
                        existingRows.forEach(row => {
                            // Ch·ªâ x√≥a n·∫øu kh√¥ng ph·∫£i l√† search box
                            if (!row.querySelector('#searchMaVanDon')) {
                                row.remove();
                            }
                        });
                        // X√≥a header c≈© n·∫øu c√≥
                        const existingHeader = body.querySelector('.row.header');
                        if (existingHeader) existingHeader.remove();
                        // X√≥a pager c≈© n·∫øu c√≥
                        const existingPager = document.getElementById('order-pager');
                        if (existingPager) existingPager.remove();
                        // X√≥a T·∫§T C·∫¢ c√°c message c≈© (.empty div)
                        const existingEmptyDivs = body.querySelectorAll('.empty');
                        existingEmptyDivs.forEach(div => div.remove());
                    }
                    
                    // Hi·ªÉn th·ªã loading
                    if (body) {
                        const loadingDiv = document.createElement('div');
                        loadingDiv.className = 'empty';
                        loadingDiv.id = 'search-loading-indicator';
                        loadingDiv.textContent = 'ƒêang t√¨m ki·∫øm...';
                        body.appendChild(loadingDiv);
                    }
                    
                    // C·∫≠p nh·∫≠t URL parameters
                    const url = new URL(window.location.href);
                    if (dateFrom) {
                        url.searchParams.set('dateFrom', dateFrom);
                    } else {
                        url.searchParams.delete('dateFrom');
                    }
                    if (dateTo) {
                        url.searchParams.set('dateTo', dateTo);
                    } else {
                        url.searchParams.delete('dateTo');
                    }
                    if (searchValue) {
                        url.searchParams.set('maVanDon', searchValue);
                    } else {
                        url.searchParams.delete('maVanDon');
                    }
                    window.history.replaceState({}, '', url);
                    
                    if (searchValue || dateFrom || dateTo) {
                        try {
                            // T·∫°o AbortController cho request n√†y
                            currentSearchController = new AbortController();
                            const controller = currentSearchController;
                            
                            // Build query parameters cho API m·ªõi - k·∫øt h·ª£p c·∫£ maVanDon v√† date
                            const params = new URLSearchParams();
                            if (searchValue) {
                                params.append('maVanDon', searchValue);
                            }
                            if (dateFrom) {
                                params.append('dateFrom', dateFrom);
                            }
                            if (dateTo) {
                                params.append('dateTo', dateTo);
                            }
                            // Th√™m ph√¢n trang
                            params.append('page', page.toString());
                            params.append('pageSize', '20');
                            
                            // G·ªçi API m·ªõi cho checker
                            const response = await fetch(`/api/orders/checker?${params.toString()}`, {
                                credentials: 'include',
                                headers: { 'Authorization': 'Bearer ' + getAuthToken() },
                                signal: controller.signal
                            });
                            
                            // Ki·ªÉm tra n·∫øu request ƒë√£ b·ªã cancel
                            if (controller !== currentSearchController) {
                                return; // Request ƒë√£ b·ªã thay th·∫ø b·ªüi request m·ªõi
                            }
                            
                            const result = await response.json();
                            
                            // Ki·ªÉm tra l·∫°i sau khi parse JSON
                            if (controller !== currentSearchController) {
                                return; // Request ƒë√£ b·ªã thay th·∫ø b·ªüi request m·ªõi
                            }
                            
                            // X√≥a loading
                            if (body) {
                                const loadingDiv = document.getElementById('search-loading-indicator');
                                if (loadingDiv) {
                                    loadingDiv.remove();
                                }
                                // X√≥a t·∫•t c·∫£ c√°c .empty div c≈© (ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng c√≤n message c≈©)
                                const oldEmptyDivs = body.querySelectorAll('.empty');
                                oldEmptyDivs.forEach(div => div.remove());
                            }
                            
                            // X√≥a loading v√† reset controller
                            currentSearchController = null;
                            
                            if (result.success && result.data && result.data.orders) {
                                // L∆∞u th√¥ng tin ph√¢n trang
                                if (result.data.pagination) {
                                    searchPagination = result.data.pagination;
                                    // L∆∞u v√†o window ƒë·ªÉ polling c√≥ th·ªÉ l·∫•y page hi·ªán t·∫°i
                                    window.currentSearchPage = result.data.pagination.page;
                                }
                                // ƒê√°nh d·∫•u c√≥ search active ƒë·ªÉ polling bi·∫øt
                                window.hasActiveSearch = true;
                                // Hi·ªÉn th·ªã k·∫øt qu·∫£ t·ª´ server v·ªõi ph√¢n trang
                                displayFilteredOrders(result.data.orders, searchValue, dateFrom, dateTo, result.data.pagination);
                                setStatus(`T√¨m th·∫•y ${result.data.pagination?.total || result.data.orders.length} ƒë∆°n h√†ng (trang ${result.data.pagination?.page || page}/${result.data.pagination?.totalPages || 1})`, 'ok');
                            } else {
                                // Hi·ªÉn th·ªã th√¥ng b√°o kh√¥ng t√¨m th·∫•y
                                displayFilteredOrders([], searchValue, dateFrom, dateTo);
                                setStatus(result.message || 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng n√†o', 'warn');
                            }
                        } catch (error) {
                            // B·ªè qua l·ªói n·∫øu request b·ªã abort
                            if (error.name === 'AbortError') {
                                return;
                            }
                            console.error('L·ªói t√¨m ki·∫øm:', error);
                            
                            // Reset controller
                            currentSearchController = null;
                            // X√≥a loading
                            if (body) {
                                const loadingDiv = document.getElementById('search-loading-indicator');
                                if (loadingDiv) {
                                    loadingDiv.remove();
                                }
                                // X√≥a t·∫•t c·∫£ c√°c .empty div c≈© (ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng c√≤n message c≈©)
                                const oldEmptyDivs = body.querySelectorAll('.empty');
                                oldEmptyDivs.forEach(div => div.remove());
                            }
                            setStatus('L·ªói khi t√¨m ki·∫øm ƒë∆°n h√†ng: ' + error.message, 'err');
                            displayFilteredOrders([], searchValue, dateFrom, dateTo);
                        }
                    } else {
                        // Hi·ªÉn th·ªã t·∫•t c·∫£ ƒë∆°n h√†ng v√† kh√¥i ph·ª•c ph√¢n trang
                        window.currentSearchValue = '';
                        window.hasActiveSearch = false;
                        window.currentSearchPage = undefined;
                        renderOrders();
                    }
                };
                
                const clearSearch = () => {
                    searchInput.value = '';
                    window.currentSearchValue = '';
                    window.hasActiveSearch = false;
                    window.currentSearchPage = undefined;
                    
                    // X√≥a gi√° tr·ªã date inputs
                    const dateFromEl = document.getElementById('dateFrom');
                    const dateToEl = document.getElementById('dateTo');
                    if (dateFromEl) dateFromEl.value = '';
                    if (dateToEl) dateToEl.value = '';
                    
                    // X√≥a tham s·ªë dateFrom, dateTo v√† maVanDon kh·ªèi URL
                    const url = new URL(window.location.href);
                    url.searchParams.delete('dateFrom');
                    url.searchParams.delete('dateTo');
                    url.searchParams.delete('maVanDon');
                    window.history.replaceState({}, '', url);
                    
                    renderOrders(); // S·ª≠ d·ª•ng renderOrders() ƒë·ªÉ kh√¥i ph·ª•c ph√¢n trang
                    startPolling(); // Kh·ªüi ƒë·ªông l·∫°i polling
                };
                
                searchBtn.onclick = () => performSearch(1);
                clearSearchBtn.onclick = clearSearch;
                
                // L∆∞u reference ƒë·ªÉ c√≥ th·ªÉ g·ªçi t·ª´ ph√¢n trang
                window.performSearch = performSearch;
                
                // T√¨m ki·∫øm khi nh·∫•n Enter
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        performSearch(1);
                    }
                });
                
                // T·ª± ƒë·ªông t√¨m ki·∫øm khi thay ƒë·ªïi date inputs v·ªõi debounce
                const dateFromInput = document.getElementById('dateFrom');
                const dateToInput = document.getElementById('dateTo');
                
                // Debounce function ƒë·ªÉ tr√°nh g·ªçi qu√° nhi·ªÅu l·∫ßn
                const debouncedSearch = () => {
                    // Clear timeout c≈©
                    if (searchTimeout) {
                        clearTimeout(searchTimeout);
                    }
                    // Set timeout m·ªõi - ƒë·ª£i 300ms sau khi ng∆∞·ªùi d√πng ng·ª´ng thay ƒë·ªïi
                    searchTimeout = setTimeout(() => {
                        performSearch(1); // Reset v·ªÅ trang 1 khi thay ƒë·ªïi filter
                        searchTimeout = null;
                    }, 300);
                };
                
                if (dateFromInput) {
                    dateFromInput.addEventListener('change', debouncedSearch);
                }
                
                if (dateToInput) {
                    dateToInput.addEventListener('change', debouncedSearch);
                }
                
                // Kh√¥i ph·ª•c gi√° tr·ªã date t·ª´ URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const savedDateFrom = urlParams.get('dateFrom');
                const savedDateTo = urlParams.get('dateTo');
                
                if (savedDateFrom && document.getElementById('dateFrom')) {
                    document.getElementById('dateFrom').value = savedDateFrom;
                }
                
                if (savedDateTo && document.getElementById('dateTo')) {
                    document.getElementById('dateTo').value = savedDateTo;
                }
                
                // L∆∞u reference ƒë·ªÉ s·ª≠ d·ª•ng trong displayFilteredOrders
                window.currentSearchValue = '';
                window.displayFilteredOrders = displayFilteredOrders;
            }
            
            // Header - ch·ªâ t·∫°o khi ƒë√£ qua ƒë∆∞·ª£c c√°c ki·ªÉm tra ·ªü tr√™n
            const header = document.createElement('div');
            header.className = 'row header';
            header.style.display = 'flex';
            header.style.fontSize = '18px';
            header.innerHTML = `
                <div style="flex:0 0 48px;min-width:40px;text-align:center;font-weight:600;padding:8px 4px;">STT</div>
                <div style="flex:0 0 160px;min-width:120px;font-weight:600;padding:8px 8px;">M√£ v·∫≠n ƒë∆°n</div>
                <div style="flex:0 0 130px;min-width:100px;font-weight:600;padding:8px 8px;">M√£ h√†ng</div>
                <div style="flex:0 0 56px;min-width:40px;text-align:center;font-weight:600;padding:8px 4px;">SL</div>
                <div style="flex:0 0 120px;min-width:80px;font-weight:600;padding:8px 8px;">M·∫´u V·∫£i</div>
                <div style="flex:1 1 320px;min-width:180px;font-weight:600;padding:8px 12px;">T√™n phi√™n b·∫£n s·∫£n ph·∫©m</div>
                <div style="flex:0 0 120px;min-width:80px;font-weight:600;padding:8px 8px;">Tr·∫°ng th√°i</div>
                <div style="flex:0 0 120px;min-width:80px;font-weight:600;padding:8px 8px;">Nh√¢n vi√™n</div>
                <div style="flex:0 0 140px;min-width:100px;font-weight:600;padding:8px 8px;">Th·ªùi gian qu√©t</div>
            `;
            body.appendChild(header);
            
            if (!cacheOrders || !Array.isArray(cacheOrders) || !cacheOrders.length) {
                body.innerHTML += '<div class="empty">Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.</div>';
                updateProgress();
                return;
            }
            
            // Ch·ªâ √°p d·ª•ng ph√¢n trang cho ch·∫ø ƒë·ªô view, kh√¥ng ph√¢n trang cho check ƒë∆°n
            let startIdx, endIdx, totalPages;
            
            if (activeView === 'view') {
                // Ph√¢n trang cho ch·∫ø ƒë·ªô view
                totalPages = Math.ceil(cacheOrders.length / pageSize);
                
                // Fix: ƒê·∫£m b·∫£o currentPage kh√¥ng v∆∞·ª£t qu√° totalPages
                if (currentPage > totalPages && totalPages > 0) {
                    currentPage = 1;
                }
                
                startIdx = (currentPage - 1) * pageSize;
                endIdx = Math.min(startIdx + pageSize, cacheOrders.length);
                
            } else {
                // Kh√¥ng ph√¢n trang cho check ƒë∆°n - hi·ªÉn th·ªã t·∫•t c·∫£
                startIdx = 0;
                endIdx = cacheOrders.length;
                totalPages = 1;
                currentPage = 1;
            }
            
            let renderedCount = 0;
            for (let i = startIdx; i < endIdx; i++) {
                const o = cacheOrders[i];
                
                const r = document.createElement('div');
                // Truy·ªÅn cacheOrders v√†o getStatus ƒë·ªÉ t√≠nh ƒë√∫ng tr·∫°ng th√°i m√£ v·∫≠n ƒë∆°n
                const status = getStatus(o, cacheOrders);
                
                // √Åp d·ª•ng m√†u s·∫Øc cho h√†ng d·ª±a tr√™n tr·∫°ng th√°i
                let rowClass = 'row';
                if (status.badge === 'b-completed') {
                    rowClass += ' status-completed';
                } else if (status.badge === 'b-processing') {
                    rowClass += ' status-processing';
                } else {
                    rowClass += ' status-pending';
                }
                
                r.className = rowClass;
                r.style.display = 'flex';
                r.style.fontSize = '17px';
                // S·ª≠ d·ª•ng logic server: hi·ªÉn th·ªã s·ªë l∆∞·ª£ng combo
                const displayQuantity = o.soLuong;
                
                // Format th·ªùi gian qu√©t
                let scanTime = '-';
                if (o.verified && o.verifiedAt) {
                    const scanDate = new Date(o.verifiedAt);
                    scanTime = scanDate.toLocaleDateString('vi-VN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    }) + ' ' + scanDate.toLocaleTimeString('vi-VN', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                }
                
                // Hi·ªÉn th·ªã nh√¢n vi√™n qu√©t
                let scannerName = '-';
                if (o.verified && o.checkingBy) {
                    scannerName = o.checkingBy;
                }

                r.innerHTML = `
                    <div style="flex:0 0 48px;min-width:40px;text-align:center;padding:8px 4px;">${o.stt}</div>
                    <div style="flex:0 0 160px;min-width:120px;padding:8px 8px;">${escapeHtml(o.maVanDon)}</div>
                    <div style="flex:0 0 130px;min-width:100px;padding:8px 8px;">${escapeHtml(o.maHang)}</div>
                    <div style="flex:0 0 56px;min-width:40px;text-align:center;padding:8px 4px;">${displayQuantity}</div>
                    <div style="flex:0 0 120px;min-width:80px;padding:8px 8px;">${escapeHtml(o.mauVai)}</div>
                    <div style="flex:1 1 320px;min-width:180px;padding:8px 12px;">${escapeHtml(o.tenPhienBan)}</div>
                    <div style="flex:0 0 120px;min-width:80px;padding:8px 8px;">
                        <span class="badge ${status.badge}" title="${status.tooltip || status.text}">
                            <span class="status-indicator ${status.badge.replace('b-', '')}"></span>
                            ${status.text}
                        </span>
                    </div>
                    <div style="flex:0 0 120px;min-width:80px;padding:8px 8px;">${scannerName}</div>
                    <div style="flex:0 0 140px;min-width:100px;padding:8px 8px;">${scanTime}</div>
                `;
                body.appendChild(r);
                renderedCount++;
            }
            
            
            // N√∫t chuy·ªÉn trang c·ªë ƒë·ªãnh - ch·ªâ hi·ªÉn th·ªã cho ch·∫ø ƒë·ªô view
            // X√≥a pager c·ªë ƒë·ªãnh n·∫øu c√≥
            const oldPager = document.getElementById('fixed-pager');
            if (oldPager) oldPager.remove();

            // T·∫°o thanh ph√¢n trang ngay d∆∞·ªõi b·∫£ng - ch·ªâ cho ch·∫ø ƒë·ªô view v√† kh√¥ng c√≥ search
            if (activeView === 'view' && totalPages > 1 && !window.currentSearchValue) {
                const pager = document.createElement('div');
                pager.id = 'order-pager';
                pager.style.display = 'flex';
                pager.style.justifyContent = 'center';
                pager.style.gap = '12px';
                pager.style.margin = '18px 0 0 0';
                const prevBtn = document.createElement('button');
                prevBtn.textContent = '‚Üê Trang tr∆∞·ªõc';
                prevBtn.className = 'btn';
                prevBtn.disabled = currentPage === 1;
                prevBtn.onclick = () => { currentPage--; renderOrders(); };
                const nextBtn = document.createElement('button');
                nextBtn.textContent = 'Trang sau ‚Üí';
                nextBtn.className = 'btn';
                nextBtn.disabled = currentPage === totalPages;
                nextBtn.onclick = () => { currentPage++; renderOrders(); };
                const info = document.createElement('span');
                info.textContent = `Trang ${currentPage} / ${totalPages}`;
                info.style.fontWeight = 'bold';
                info.style.fontSize = '16px';
                pager.appendChild(prevBtn);
                pager.appendChild(info);
                pager.appendChild(nextBtn);
                body.appendChild(pager);
            }
// ·∫®n ho√†n to√†n thanh ph√¢n trang khi chuy·ªÉn sang ch·ª©c nƒÉng kh√°c ngo√†i Xem ƒë∆°n h√†ng
window.hideOrderPager = function() {
    const pager = document.getElementById('fixed-pager');
    if (pager) pager.style.display = 'none';
}

// ·∫®n thanh ph√¢n trang khi chuy·ªÉn sang ch·ª©c nƒÉng kh√°c
window.showOrderPager = function(show) {
    const pager = document.getElementById('fixed-pager');
    if (pager) pager.style.visibility = show ? 'visible' : 'hidden';
}
// G·ªçi showOrderPager(false) khi chuy·ªÉn sang ch·ª©c nƒÉng kh√°c ngo√†i Xem ƒë∆°n h√†ng
            
            // T·ª± ƒë·ªông √°p d·ª•ng filter n·∫øu c√≥ date parameters trong URL
            const urlParams = new URLSearchParams(window.location.search);
            const savedDateFrom = urlParams.get('dateFrom');
            const savedDateTo = urlParams.get('dateTo');
            
                if (savedDateFrom || savedDateTo) {
                setTimeout(() => {
                    const dateFromEl = document.getElementById('dateFrom');
                    const dateToEl = document.getElementById('dateTo');
                    if (dateFromEl && savedDateFrom) dateFromEl.value = savedDateFrom;
                    if (dateToEl && savedDateTo) dateToEl.value = savedDateTo;
                    if (window.performSearch) {
                        window.performSearch(1);
                    }
                }, 100);
            }
            
            updateProgress();
        }

        // H√†m hi·ªÉn th·ªã ƒë∆°n h√†ng ƒë√£ l·ªçc (cho ch·ª©c nƒÉng search)
        function displayFilteredOrders(filteredOrders, searchValue, dateFrom = null, dateTo = null, pagination = null) {
            const body = document.getElementById('rows');
            if (!body) return;
            
            // L∆∞u gi√° tr·ªã search hi·ªán t·∫°i
            window.currentSearchValue = searchValue;
            // ƒê√°nh d·∫•u c√≥ search active (n·∫øu c√≥ searchValue ho·∫∑c date filter)
            window.hasActiveSearch = !!(searchValue || dateFrom || dateTo);
            
            // X√≥a T·∫§T C·∫¢ c√°c message c≈© (.empty div) tr∆∞·ªõc khi hi·ªÉn th·ªã k·∫øt qu·∫£ m·ªõi
            const existingEmptyDivs = body.querySelectorAll('.empty');
            existingEmptyDivs.forEach(div => div.remove());
            
            // X√≥a loading indicator n·∫øu c√≤n
            const loadingDiv = document.getElementById('search-loading-indicator');
            if (loadingDiv) {
                loadingDiv.remove();
            }
            
            // T√¨m v√† x√≥a header c≈© (n·∫øu c√≥)
            const existingHeader = body.querySelector('.row.header');
            if (existingHeader) {
                existingHeader.remove();
            }
            
            // T·∫°o header m·ªõi
            const header = document.createElement('div');
            header.className = 'row header';
            header.style.display = 'flex';
            header.style.fontSize = '18px';
            header.innerHTML = `
                <div style="flex:0 0 48px;min-width:40px;text-align:center;font-weight:600;padding:8px 4px;">STT</div>
                <div style="flex:0 0 160px;min-width:120px;font-weight:600;padding:8px 8px;">M√£ v·∫≠n ƒë∆°n</div>
                <div style="flex:0 0 130px;min-width:100px;font-weight:600;padding:8px 8px;">M√£ h√†ng</div>
                <div style="flex:0 0 56px;min-width:40px;text-align:center;font-weight:600;padding:8px 4px;">SL</div>
                <div style="flex:0 0 120px;min-width:80px;font-weight:600;padding:8px 8px;">M·∫´u V·∫£i</div>
                <div style="flex:1 1 320px;min-width:180px;font-weight:600;padding:8px 12px;">T√™n phi√™n b·∫£n s·∫£n ph·∫©m</div>
                <div style="flex:0 0 120px;min-width:80px;font-weight:600;padding:8px 8px;">Tr·∫°ng th√°i</div>
                <div style="flex:0 0 120px;min-width:80px;font-weight:600;padding:8px 8px;">Nh√¢n vi√™n</div>
                <div style="flex:0 0 140px;min-width:100px;font-weight:600;padding:8px 8px;">Th·ªùi gian qu√©t</div>
            `;
            body.appendChild(header);
            
            // X√≥a c√°c row c≈© (tr·ª´ search box v√† header)
            const existingRows = body.querySelectorAll('.row:not(.header)');
            existingRows.forEach(row => {
                if (!row.querySelector('#searchMaVanDon')) { // Kh√¥ng x√≥a search box
                    row.remove();
                }
            });
            
            if (!filteredOrders || !Array.isArray(filteredOrders) || !filteredOrders.length) {
                // ƒê·∫£m b·∫£o ƒë√£ x√≥a t·∫•t c·∫£ message c≈©
                const allEmptyDivs = body.querySelectorAll('.empty');
                allEmptyDivs.forEach(div => div.remove());
                
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'empty';
                emptyDiv.id = 'no-results-message';
                
                let message = 'Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã.';
                if (searchValue && (dateFrom || dateTo)) {
                    message = `Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng n√†o v·ªõi m√£ v·∫≠n ƒë∆°n "${searchValue}" trong kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn.`;
                } else if (searchValue) {
                    message = `Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng n√†o v·ªõi m√£ v·∫≠n ƒë∆°n "${searchValue}".`;
                } else if (dateFrom || dateTo) {
                    message = 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng n√†o trong kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn.';
                }
                
                emptyDiv.textContent = message;
                body.appendChild(emptyDiv);
                updateProgress();
                return;
            }
            
            // X√≥a ph√¢n trang c≈© n·∫øu c√≥
            const existingPager = document.getElementById('order-pager');
            if (existingPager) {
                existingPager.remove();
            }
            
            // Hi·ªÉn th·ªã ph√¢n trang cho k·∫øt qu·∫£ t√¨m ki·∫øm n·∫øu c√≥
            if (pagination && pagination.totalPages > 1) {
                const searchPager = document.createElement('div');
                searchPager.id = 'order-pager';
                searchPager.style.display = 'flex';
                searchPager.style.justifyContent = 'center';
                searchPager.style.gap = '12px';
                searchPager.style.margin = '18px 0 0 0';
                
                const prevBtn = document.createElement('button');
                prevBtn.textContent = '‚Üê Trang tr∆∞·ªõc';
                prevBtn.className = 'btn';
                prevBtn.disabled = pagination.page === 1;
                prevBtn.onclick = () => {
                    const searchInput = document.getElementById('searchMaVanDon');
                    const dateFromInput = document.getElementById('dateFrom');
                    const dateToInput = document.getElementById('dateTo');
                    if (window.performSearch) {
                        window.performSearch(pagination.page - 1);
                    }
                };
                
                const nextBtn = document.createElement('button');
                nextBtn.textContent = 'Trang sau ‚Üí';
                nextBtn.className = 'btn';
                nextBtn.disabled = pagination.page >= pagination.totalPages;
                nextBtn.onclick = () => {
                    const searchInput = document.getElementById('searchMaVanDon');
                    const dateFromInput = document.getElementById('dateFrom');
                    const dateToInput = document.getElementById('dateTo');
                    if (window.performSearch) {
                        window.performSearch(pagination.page + 1);
                    }
                };
                
                const info = document.createElement('span');
                info.textContent = `Trang ${pagination.page} / ${pagination.totalPages} (T·ªïng: ${pagination.total} ƒë∆°n h√†ng)`;
                info.style.fontWeight = 'bold';
                info.style.fontSize = '16px';
                
                searchPager.appendChild(prevBtn);
                searchPager.appendChild(info);
                searchPager.appendChild(nextBtn);
                body.appendChild(searchPager);
            }
            
            // Hi·ªÉn th·ªã k·∫øt qu·∫£ t√¨m ki·∫øm
            filteredOrders.forEach((o, index) => {
                const r = document.createElement('div');
                // Truy·ªÅn filteredOrders v√†o getStatus ƒë·ªÉ t√≠nh ƒë√∫ng tr·∫°ng th√°i m√£ v·∫≠n ƒë∆°n
                const status = getStatus(o, filteredOrders);
                
                // √Åp d·ª•ng m√†u s·∫Øc cho h√†ng d·ª±a tr√™n tr·∫°ng th√°i
                let rowClass = 'row';
                if (status.badge === 'b-completed') {
                    rowClass += ' status-completed';
                } else if (status.badge === 'b-processing') {
                    rowClass += ' status-processing';
                } else {
                    rowClass += ' status-pending';
                }
                
                r.className = rowClass;
                r.style.display = 'flex';
                r.style.fontSize = '17px';
                
                // Highlight m√£ v·∫≠n ƒë∆°n n·∫øu ƒëang search
                let maVanDonDisplay = escapeHtml(o.maVanDon);
                if (searchValue) {
                    const regex = new RegExp(`(${escapeRegex(searchValue)})`, 'gi');
                    maVanDonDisplay = maVanDonDisplay.replace(regex, '<mark style="background: #fbbf24; color: #1f2937; padding: 1px 2px; border-radius: 2px;">$1</mark>');
                }
                
                // Format th·ªùi gian qu√©t
                let scanTime = '-';
                if (o.verified && o.verifiedAt) {
                    const scanDate = new Date(o.verifiedAt);
                    scanTime = scanDate.toLocaleDateString('vi-VN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    }) + ' ' + scanDate.toLocaleTimeString('vi-VN', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                }
                
                // Hi·ªÉn th·ªã nh√¢n vi√™n qu√©t
                let scannerName = '-';
                if (o.verified && o.checkingBy) {
                    scannerName = o.checkingBy;
                }

                r.innerHTML = `
                    <div style="flex:0 0 48px;min-width:40px;text-align:center;padding:8px 4px;">${index + 1}</div>
                    <div style="flex:0 0 160px;min-width:120px;padding:8px 8px;">${maVanDonDisplay}</div>
                    <div style="flex:0 0 130px;min-width:100px;padding:8px 8px;">${escapeHtml(o.maHang)}</div>
                    <div style="flex:0 0 56px;min-width:40px;text-align:center;padding:8px 4px;">${o.soLuong}</div>
                    <div style="flex:0 0 120px;min-width:80px;padding:8px 8px;">${escapeHtml(o.mauVai)}</div>
                    <div style="flex:1 1 320px;min-width:180px;padding:8px 12px;">${escapeHtml(o.tenPhienBan)}</div>
                    <div style="flex:0 0 120px;min-width:80px;padding:8px 8px;">
                        <span class="badge ${status.badge}" title="${status.tooltip || status.text}">
                            <span class="status-indicator ${status.badge.replace('b-', '')}"></span>
                            ${status.text}
                        </span>
                    </div>
                    <div style="flex:0 0 120px;min-width:80px;padding:8px 8px;">${scannerName}</div>
                    <div style="flex:0 0 140px;min-width:100px;padding:8px 8px;">${scanTime}</div>
                `;
                body.appendChild(r);
            });
            
            // C·∫≠p nh·∫≠t progress v·ªõi th√¥ng tin search
            updateProgress();
        }

        // H√†m escape regex ƒë·ªÉ tr√°nh l·ªói khi search
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function getStatus(o, ordersList = null) {
            // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô view (xem ƒë∆°n), hi·ªÉn th·ªã tr·∫°ng th√°i theo logic m·ªõi
            if (activeView === 'view') {
                return getOrderStatus(o, ordersList);
            }
            
            // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô check, hi·ªÉn th·ªã ti·∫øn ƒë·ªô qu√©t chi ti·∫øt
            const currentScannedItems = orderCheckSM.scannedItems || scannedItems;
            const scannedItemsForThisProduct = currentScannedItems.filter(item => item.maHang === o.maHang);
            
            // ƒê·∫øm s·ªë l·∫ßn qu√©t cho m√£ h√†ng n√†y (m·ªói l·∫ßn qu√©t = 1)
            let scanned = scannedItemsForThisProduct.length;
            
            const required = o.soLuong;
            
            // X√°c ƒë·ªãnh tr·∫°ng th√°i v√† m√†u s·∫Øc d·ª±a tr√™n ti·∫øn ƒë·ªô qu√©t
            if (scanned === 0) {
                // Ch∆∞a qu√©t g√¨
                return { 
                    text: `0/${required}`, 
                    badge: 'b-pending',
                    tooltip: 'Ch∆∞a qu√©t'
                };
            } else if (scanned < required) {
                // ƒêang qu√©t m·ªôt ph·∫ßn
                return { 
                    text: `${scanned}/${required}`, 
                    badge: 'b-progress',
                    tooltip: `ƒêang qu√©t (c√≤n thi·∫øu ${required - scanned})`
                };
            } else if (scanned >= required) {
                // ƒê√£ qu√©t ƒë·ªß ho·∫∑c th·ª´a
                return { 
                    text: `${scanned}/${required}`, 
                    badge: 'b-done',
                    tooltip: scanned > required ? `ƒê√£ qu√©t ƒë·ªß (th·ª´a ${scanned - required})` : 'ƒê√£ qu√©t ƒë·ªß'
                };
            }
            
            // Fallback
            return { text: `${scanned}/${required}`, badge: 'b-info' };
        }
        
        function getOrderStatus(o, ordersList = null) {
            // Logic tr·∫°ng th√°i ƒë∆°n h√†ng d·ª±a tr√™n tr·∫°ng th√°i c·ªßa to√†n b·ªô maVanDon:
            // [Ch∆∞a x·ª≠ l√Ω]: maVanDon ch∆∞a ho√†n th√†nh v√† kh√¥ng c√≥ block
            // [ƒêang x·ª≠ l√Ω]: maVanDon ch∆∞a ho√†n th√†nh v√† c√≥ block  
            // [Ho√†n th√†nh]: maVanDon ƒë√£ ho√†n th√†nh (t·∫•t c·∫£ maHang ƒë√£ verified = true)
            
            // S·ª≠ d·ª•ng ordersList n·∫øu c√≥ (khi ƒëang search), n·∫øu kh√¥ng d√πng cacheOrders
            const sourceOrders = ordersList || cacheOrders;
            
            // Ki·ªÉm tra tr·∫°ng th√°i c·ªßa to√†n b·ªô maVanDon
            const vanDonOrders = sourceOrders.filter(order => order.maVanDon === o.maVanDon);
            const totalItems = vanDonOrders.length;
            const completedItems = vanDonOrders.filter(order => order.verified).length;
            const isVanDonCompleted = totalItems > 0 && totalItems === completedItems;
            
            if (isVanDonCompleted) {
                return { text: 'Ho√†n th√†nh', badge: 'b-completed' };
            } else if (o.block && !isVanDonCompleted) {
                return { text: 'ƒêang x·ª≠ l√Ω', badge: 'b-processing' };
            } else {
                return { text: 'Ch∆∞a x·ª≠ l√Ω', badge: 'b-pending' };
            }
        }

        // H√†m load d·ªØ li·ªáu ƒë∆°n h·ªßy t·ª´ UserBehaviour
        // Bi·∫øn l∆∞u tr·ªØ d·ªØ li·ªáu ƒë∆°n h·ªßy g·ªëc, b·ªô l·ªçc v√† ph√¢n trang
        let allCancelledOrders = [];
        let cancelledFilters = {
            dateFrom: '',
            dateTo: '',
            user: '',
            searchText: ''
        };
        let cancelledPage = 1;
        const CANCELLED_PAGE_SIZE = 50;

        async function loadCancelledOrders() {
            try {
                setStatus('ƒêang t·∫£i danh s√°ch ƒë∆°n h·ªßy...', 'info');
                // L·∫•y gi√° tr·ªã ng√†y t·ª´ UI (n·∫øu c√≥) ƒë·ªÉ truy·ªÅn l√™n server v√† gi·∫£m t·∫£i
                const uiDateFrom = document.getElementById('cancelledDateFrom')?.value || cancelledFilters.dateFrom || '';
                const uiDateTo = document.getElementById('cancelledDateTo')?.value || cancelledFilters.dateTo || '';

                // G·ªçi API ƒë·ªÉ l·∫•y user behaviour v·ªõi action "H·ªßy ƒë∆°n"; truy·ªÅn filter ng√†y n·∫øu c√≥
                const params = new URLSearchParams();
                params.set('method', 'scanner');
                params.set('limit', '2000'); // client-side pagination will slice
                if (uiDateFrom) params.set('dateFrom', uiDateFrom);
                if (uiDateTo) params.set('dateTo', uiDateTo);

                const response = await fetch('/api/user-behaviour?' + params.toString(), {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + getAuthToken()
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.message || 'L·ªói khi t·∫£i d·ªØ li·ªáu');
                }
                
                // L·ªçc c√°c behaviour c√≥ ch·ª©a "H·ªßy ƒë∆°n" trong description
                const behaviours = result.data?.behaviours || result.data || [];
                const cancelledBehaviours = behaviours.filter(behaviour => 
                    behaviour.description && behaviour.description.toLowerCase().includes('h·ªßy ƒë∆°n')
                );

                // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã
                const cancelledOrders = cancelledBehaviours.map(behaviour => {
                    const description = behaviour.description || '';

                    // Th·ª≠ l·∫•y maVanDon t·ª´ metadata n·∫øu c√≥, ng∆∞·ª£c l·∫°i parse t·ª´ description (h·ªó tr·ª£ d·∫•u '-')
                    let maVanDon = (behaviour.metadata && (behaviour.metadata.maVanDon || behaviour.metadata.orderId)) || '';
                    if (!maVanDon) {
                        const maVanDonMatch = description.match(/(?:ƒë∆°n\s*)?([A-Za-z0-9\-]+)/i);
                        maVanDon = maVanDonMatch ? maVanDonMatch[1] : 'N/A';
                    }

                    // Parse s·ªë l∆∞·ª£ng h√†ng thi·∫øu t·ª´ metadata ho·∫∑c description
                    let missingQuantity = 0;
                    let missingItemsDetail = null;
                    if (behaviour.metadata && behaviour.metadata.missingItems && Array.isArray(behaviour.metadata.missingItems)) {
                        missingItemsDetail = behaviour.metadata.missingItems.map(it => ({ name: it.maHang || it.name || '', qty: it.soLuongThieu || it.qty || 0 }));
                        missingQuantity = missingItemsDetail.reduce((sum, item) => sum + (item.qty || 0), 0);
                    } else {
                        // Fallback: parse t·ª´ description
                        const missingMatch = description.match(/thi·∫øu\s+(\d+)/i);
                        if (missingMatch) {
                            missingQuantity = parseInt(missingMatch[1]);
                        }
                    }

                    return {
                        id: behaviour._id,
                        maVanDon: maVanDon,
                        user: behaviour.user || (behaviour.metadata && behaviour.metadata.user) || 'unknown',
                        time: new Date(behaviour.time),
                        description: description,
                        missingQuantity: missingQuantity,
                        missingItemsDetail: missingItemsDetail,
                        metadata: behaviour.metadata || {}
                    };
                });
                
                // L∆∞u d·ªØ li·ªáu g·ªëc
                allCancelledOrders = cancelledOrders;
                
                // L∆∞u d·ªØ li·ªáu g·ªëc v√† reset ph√¢n trang
                allCancelledOrders = cancelledOrders;
                cancelledPage = 1;

                // √Åp d·ª•ng b·ªô l·ªçc
                applyCancelledFilters();
                
                setStatus(`ƒê√£ t·∫£i ${allCancelledOrders.length} ƒë∆°n h·ªßy`, 'success');
                
            } catch (error) {
                setStatus('L·ªói khi t·∫£i danh s√°ch ƒë∆°n h·ªßy: ' + error.message, 'err');
                allCancelledOrders = [];
                cacheOrders = [];
                renderCancelledOrders();
            }
        }
        
        // H√†m √°p d·ª•ng b·ªô l·ªçc cho ƒë∆°n h·ªßy
        function applyCancelledFilters() {
            let filteredOrders = [...allCancelledOrders];
            
            // L·ªçc theo ng√†y t·ª´
            if (cancelledFilters.dateFrom) {
                const fromDate = new Date(cancelledFilters.dateFrom);
                filteredOrders = filteredOrders.filter(order => order.time >= fromDate);
            }
            
            // L·ªçc theo ng√†y ƒë·∫øn
            if (cancelledFilters.dateTo) {
                const toDate = new Date(cancelledFilters.dateTo);
                toDate.setHours(23, 59, 59, 999); // ƒê·∫øn cu·ªëi ng√†y
                filteredOrders = filteredOrders.filter(order => order.time <= toDate);
            }
            
            // L·ªçc theo nh√¢n vi√™n
            if (cancelledFilters.user) {
                filteredOrders = filteredOrders.filter(order => 
                    order.user && order.user.toLowerCase().includes(cancelledFilters.user.toLowerCase())
                );
            }
            
            // L·ªçc theo t·ª´ kh√≥a t√¨m ki·∫øm (m√£ v·∫≠n ƒë∆°n)
            if (cancelledFilters.searchText) {
                filteredOrders = filteredOrders.filter(order => 
                    order.maVanDon.toLowerCase().includes(cancelledFilters.searchText.toLowerCase())
                );
            }
            
            // C·∫≠p nh·∫≠t cacheOrders ƒë·ªÉ hi·ªÉn th·ªã
            cacheOrders = filteredOrders;
            
            // Render danh s√°ch
            renderCancelledOrders();
        }
        
        // H√†m render danh s√°ch ƒë∆°n h·ªßy v·ªõi giao di·ªán chuy√™n nghi·ªáp
        function renderCancelledOrders() {
            const body = document.getElementById('rows');
            body.innerHTML = '';
            
            
            // B·ªô l·ªçc n√¢ng cao
            const filterPanel = document.createElement('div');
            filterPanel.style.cssText = `
                background: #1e293b;
                padding: 24px;
                margin-bottom: 24px;
                border-radius: 12px;
                border: 1px solid #334155;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            `;
            
            filterPanel.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #f8fafc; font-size: 20px; font-weight: 600; margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
                        üîç B·ªô L·ªçc N√¢ng Cao
                    </h3>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="color: #e2e8f0; font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                            üìÖ T·ª´ ng√†y
                        </label>
                        <input type="date" id="cancelledDateFrom" style="
                            padding: 12px; 
                            border-radius: 8px; 
                            border: 2px solid #475569; 
                            background: #334155; 
                            color: #e2e8f0; 
                            font-size: 14px;
                            transition: all 0.2s;
                        " onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" 
                        onblur="this.style.borderColor='#475569'; this.style.boxShadow='none'">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="color: #e2e8f0; font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                            üìÖ ƒê·∫øn ng√†y
                        </label>
                        <input type="date" id="cancelledDateTo" style="
                            padding: 12px; 
                            border-radius: 8px; 
                            border: 2px solid #475569; 
                            background: #334155; 
                            color: #e2e8f0; 
                            font-size: 14px;
                            transition: all 0.2s;
                        " onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" 
                        onblur="this.style.borderColor='#475569'; this.style.boxShadow='none'">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="color: #e2e8f0; font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                            üë§ Nh√¢n vi√™n
                        </label>
                        <input type="text" id="cancelledUserFilter" placeholder="T√¨m theo t√™n nh√¢n vi√™n..." style="
                            padding: 12px; 
                            border-radius: 8px; 
                            border: 2px solid #475569; 
                            background: #334155; 
                            color: #e2e8f0; 
                            font-size: 14px;
                            transition: all 0.2s;
                        " onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" 
                        onblur="this.style.borderColor='#475569'; this.style.boxShadow='none'">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="color: #e2e8f0; font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                            üè∑Ô∏è M√£ v·∫≠n ƒë∆°n
                        </label>
                        <input type="text" id="cancelledSearchText" placeholder="T√¨m m√£ v·∫≠n ƒë∆°n..." style="
                            padding: 12px; 
                            border-radius: 8px; 
                            border: 2px solid #475569; 
                            background: #334155; 
                            color: #e2e8f0; 
                            font-size: 14px;
                            transition: all 0.2s;
                        " onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" 
                        onblur="this.style.borderColor='#475569'; this.style.boxShadow='none'">
                    </div>
                </div>
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button id="clearCancelledFilters" style="
                        padding: 12px 24px; 
                        background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); 
                        color: white; 
                        border: none; 
                        border-radius: 8px; 
                        cursor: pointer; 
                        font-weight: 600;
                        font-size: 14px;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        box-shadow: 0 2px 4px rgba(107, 114, 128, 0.3);
                        transition: all 0.2s;
                    " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(107, 114, 128, 0.4)'" 
                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(107, 114, 128, 0.3)'">
                        üóëÔ∏è X√≥a L·ªçc
                    </button>
                    <button id="applyCancelledFilters" style="
                        padding: 12px 24px; 
                        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); 
                        color: white; 
                        border: none; 
                        border-radius: 8px; 
                        cursor: pointer; 
                        font-weight: 600;
                        font-size: 14px;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
                        transition: all 0.2s;
                    " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(59, 130, 246, 0.4)'" 
                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(59, 130, 246, 0.3)'">
                        üîç √Åp D·ª•ng L·ªçc
                    </button>
                </div>
            `;
            
            body.appendChild(filterPanel);
            
            
            // B·∫£ng d·ªØ li·ªáu
            const tableContainer = document.createElement('div');
            tableContainer.style.cssText = `
                background: #1e293b;
                border-radius: 12px;
                border: 1px solid #334155;
                overflow: hidden;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            `;
            
            // Header b·∫£ng
            const tableHeader = document.createElement('div');
            tableHeader.style.cssText = `
                background: linear-gradient(135deg, #334155 0%, #475569 100%);
                padding: 16px 20px;
                display: flex;
                font-size: 16px;
                font-weight: 700;
                color: #f8fafc;
                border-bottom: 2px solid #475569;
            `;
            
            tableHeader.innerHTML = `
                <div style="flex: 0 0 180px; min-width: 150px; padding: 0 12px;">M√£ V·∫≠n ƒê∆°n</div>
                <div style="flex: 0 0 140px; min-width: 120px; padding: 0 12px;">Nh√¢n Vi√™n</div>
                <div style="flex: 0 0 180px; min-width: 150px; padding: 0 12px;">Th·ªùi Gian H·ªßy</div>
                <div style="flex: 0 0 120px; min-width: 100px; padding: 0 12px; text-align: center;">H√†ng Thi·∫øu</div>
                <div style="flex: 0 0 100px; min-width: 80px; padding: 0 12px; text-align: center;">Tr·∫°ng Th√°i</div>
                <div style="flex: 1 1 300px; min-width: 200px; padding: 0 12px;">M√¥ T·∫£</div>
            `;
            
            tableContainer.appendChild(tableHeader);
            
            // Body b·∫£ng
            const tableBody = document.createElement('div');
            tableBody.id = 'cancelledTableBody';
            tableBody.style.cssText = `
                max-height: 500px;
                overflow-y: auto;
            `;
            
            // Paginate cacheOrders for display
            const startIdx = (cancelledPage - 1) * CANCELLED_PAGE_SIZE;
            const pageSlice = cacheOrders.slice(startIdx, startIdx + CANCELLED_PAGE_SIZE);

            if (!pageSlice.length) {
                tableBody.innerHTML = `
                    <div style="
                        padding: 40px 20px; 
                        text-align: center; 
                        color: #94a3b8; 
                        font-size: 16px;
                        background: #1e293b;
                    ">
                        <div style="font-size: 48px; margin-bottom: 16px;">üì≠</div>
                        <div>Kh√¥ng c√≥ ƒë∆°n h·ªßy n√†o ph√π h·ª£p v·ªõi b·ªô l·ªçc</div>
                    </div>
                `;
        } else {
        pageSlice.forEach((order, index) => {
                    const row = document.createElement('div');
                    row.style.cssText = `
                        padding: 16px 20px;
                        display: flex;
                        font-size: 14px;
                        border-bottom: 1px solid #334155;
                        background: ${index % 2 === 0 ? '#1e293b' : '#0f172a'};
                        transition: background-color 0.2s;
                    `;
                    
                    row.innerHTML = `
                        <div style="flex: 0 0 180px; min-width: 150px; padding: 0 12px; font-weight: 600; color: #3b82f6;">${escapeHtml(order.maVanDon)}</div>
                        <div style="flex: 0 0 140px; min-width: 120px; padding: 0 12px; color: #e2e8f0;">${escapeHtml(order.user)}</div>
                        <div style="flex: 0 0 180px; min-width: 150px; padding: 0 12px; color: #94a3b8;">${order.time.toLocaleString('vi-VN')}</div>
                        <div style="flex: 0 0 120px; min-width: 100px; padding: 0 12px; text-align: center;">
                            <span style="
                                background: #dc2626; 
                                color: white; 
                                padding: 4px 8px; 
                                border-radius: 6px; 
                                font-weight: 600;
                                font-size: 12px;
                            ">${order.missingQuantity}</span>
                        </div>
                        <div style="flex: 0 0 100px; min-width: 80px; padding: 0 12px; text-align: center;">
                            <span style="
                                background: #f59e0b; 
                                color: white; 
                                padding: 4px 8px; 
                                border-radius: 6px; 
                                font-weight: 600;
                                font-size: 12px;
                            ">H·ªßy</span>
                        </div>
                        <div style="flex: 1 1 300px; min-width: 200px; padding: 0 12px; color: #cbd5e1; line-height: 1.4;">
                            ${escapeHtml(order.description)}
                            ${order.missingItemsDetail && order.missingItemsDetail.length ? '<div style="margin-top:8px;color:#fecaca;font-size:13px;"><strong>Chi ti·∫øt thi·∫øu:</strong> ' + order.missingItemsDetail.map(it => escapeHtml(it.name) + ' √ó' + it.qty).join(', ') + '</div>' : ''}
                        </div>
                    `;
                    
                    tableBody.appendChild(row);
                });
            }
            
            tableContainer.appendChild(tableBody);
            body.appendChild(tableContainer);

            // Pagination controls
            const totalPages = Math.max(1, Math.ceil(cacheOrders.length / CANCELLED_PAGE_SIZE));
            const pagination = document.createElement('div');
            pagination.style.cssText = 'display:flex; gap:8px; align-items:center; justify-content:right; margin-top:12px;';

            const prevBtn = document.createElement('button');
            prevBtn.className = 'btn secondary';
            prevBtn.textContent = '‚Äπ Tr∆∞·ªõc';
            prevBtn.disabled = cancelledPage <= 1;
            prevBtn.onclick = () => { if (cancelledPage > 1) { cancelledPage--; renderCancelledOrders(); ensureInputFocus(); } };

            const nextBtn = document.createElement('button');
            nextBtn.className = 'btn secondary';
            nextBtn.textContent = 'K·∫ø Ti·∫øp ‚Ä∫';
            nextBtn.disabled = cancelledPage >= totalPages;
            nextBtn.onclick = () => { if (cancelledPage < totalPages) { cancelledPage++; renderCancelledOrders(); ensureInputFocus(); } };

            const pageInfo = document.createElement('div');
            pageInfo.style.cssText = 'color:#64748b; font-weight:600;';
            pageInfo.textContent = `Trang ${cancelledPage} / ${totalPages}`;

            pagination.appendChild(prevBtn);
            pagination.appendChild(pageInfo);
            pagination.appendChild(nextBtn);
            body.appendChild(pagination);
            
            // Event listeners
            document.getElementById('applyCancelledFilters').onclick = async () => {
                cancelledFilters.dateFrom = document.getElementById('cancelledDateFrom').value;
                cancelledFilters.dateTo = document.getElementById('cancelledDateTo').value;
                cancelledFilters.user = document.getElementById('cancelledUserFilter').value;
                cancelledFilters.searchText = document.getElementById('cancelledSearchText').value;
                cancelledPage = 1;
                // Reload from server when date filters change to reduce client data
                await loadCancelledOrders();
            };
            
            document.getElementById('clearCancelledFilters').onclick = async () => {
                cancelledFilters = { dateFrom: '', dateTo: '', user: '', searchText: '' };
                document.getElementById('cancelledDateFrom').value = '';
                document.getElementById('cancelledDateTo').value = '';
                document.getElementById('cancelledUserFilter').value = '';
                document.getElementById('cancelledSearchText').value = '';
                cancelledPage = 1;
                await loadCancelledOrders();
            };
            
            
            // Enter ƒë·ªÉ l·ªçc
            ['cancelledDateFrom', 'cancelledDateTo', 'cancelledUserFilter', 'cancelledSearchText'].forEach(id => {
                document.getElementById(id).addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('applyCancelledFilters').click();
                    }
                });
            });
            
            updateProgress();
        }



        function updateProgress() {
            const total = cacheOrders.length;
            
            let scanned = 0;
            let completed = 0;
            let inProgress = 0;
            
            // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô check (scanning), t√≠nh t·ª´ scannedItems
            if (activeView === 'check' && orderCheckSM.scannedItems) {
                const currentScannedItems = orderCheckSM.scannedItems || scannedItems;
                
                // T√≠nh t·ªïng s·ªë l·∫ßn qu√©t th·ª±c t·∫ø
                scanned = currentScannedItems.length;
                
                // T√≠nh s·ªë s·∫£n ph·∫©m ƒë√£ qu√©t ƒë·ªß v√† ƒëang qu√©t (ƒë·∫øm s·ªë l·∫ßn qu√©t)
                cacheOrders.forEach(order => {
                    const scannedItemsForThisProduct = currentScannedItems.filter(item => item.maHang === order.maHang);
                    const scannedCount = scannedItemsForThisProduct.length;
                    
                    if (scannedCount >= order.soLuong) {
                        completed++;
                    } else if (scannedCount > 0) {
                        inProgress++;
                    }
                });
            } else {
                // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô view, t√≠nh t·ª´ cacheOrders (verified t·ª´ DB)
                completed = cacheOrders.filter(x => x.verified).length;
                scanned = cacheOrders.reduce((sum, order) => {
                    return sum + (order.scannedQuantity || 0);
                }, 0);
            }
            
            const required = cacheOrders.reduce((s, x) => s + x.soLuong, 0);
            
            // T√≠nh ph·∫ßn trƒÉm d·ª±a tr√™n s·ªë s·∫£n ph·∫©m ƒë√£ ho√†n th√†nh
            const percent = total ? Math.round((completed / total) * 100) : 0;
            
            // Hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt h∆°n
            let progressText = '';
            if (activeView === 'cancelled') {
                // ƒê∆°n h·ªßy: hi·ªÉn th·ªã t·ªïng s·ªë ƒë∆°n h·ªßy
                const totalMissing = cacheOrders.reduce((sum, order) => sum + (order.missingQuantity || 0), 0);
                progressText = `${total} ƒë∆°n h·ªßy ¬∑ ${totalMissing} h√†ng thi·∫øu`;
            } else if (activeView === 'check') {
                progressText = `${completed}/${total} ho√†n th√†nh ¬∑ ${scanned}/${required} ƒë√£ qu√©t`;
                if (inProgress > 0) {
                    progressText += ` ¬∑ ${inProgress} ƒëang qu√©t`;
                }
            } else {
                progressText = `${completed}/${total} ho√†n th√†nh ¬∑ ${scanned}/${required} ƒë√£ qu√©t`;
                
                // Th√™m th√¥ng tin search n·∫øu ƒëang search
                if (window.currentSearchValue) {
                    progressText += ` ¬∑ T√¨m ki·∫øm: "${window.currentSearchValue}"`;
                }
            }
            
            document.getElementById('progressText').textContent = progressText;
            document.getElementById('bar').style.width = percent + '%';
        }

        // H√†m load th·ªëng k√™ theo nh√¢n vi√™n theo ng√†y
        async function loadStats() {
            try {
                setStatus('ƒêang t·∫£i th·ªëng k√™...', 'info');
                
                // L·∫•y ng√†y hi·ªán t·∫°i l√†m m·∫∑c ƒë·ªãnh
                const today = new Date().toISOString().split('T')[0];
                const selectedDate = document.getElementById('statsDatePicker')?.value || today;
                
                console.log('Loading stats for date:', selectedDate);
                
                const response = await fetch(`/api/stats/orders-by-employee?date=${selectedDate}`, {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + getAuthToken()
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.message || 'L·ªói khi t·∫£i th·ªëng k√™');
                }
                
                console.log('Stats loaded:', result.data);
                
                // Hi·ªÉn th·ªã th·ªëng k√™
                displayStats(result.data);
                
                setStatus(`ƒê√£ t·∫£i th·ªëng k√™ ng√†y ${result.data.date}`, 'success');
                
            } catch (error) {
                console.error('Error loading stats:', error);
                setStatus('L·ªói khi t·∫£i th·ªëng k√™: ' + error.message, 'err');
                displayStatsError(error.message);
            }
        }
        
        // H√†m hi·ªÉn th·ªã th·ªëng k√™
        function displayStats(data) {
            const body = document.getElementById('rows');
            body.innerHTML = '';
            
            // Container ch√≠nh
            const statsContainer = document.createElement('div');
            statsContainer.className = 'stats-container';
            
            // Header v·ªõi date picker
            const statsHeader = document.createElement('div');
            statsHeader.className = 'stats-header';
            
            const today = new Date().toISOString().split('T')[0];
            
            statsHeader.innerHTML = `
                <h2 class="stats-title">Th·ªëng k√™ ƒë∆°n h√†ng theo nh√¢n vi√™n</h2>
                <div class="date-picker-container">
                    <label style="font-weight: 600; color: #334155;">Ng√†y:</label>
                    <input type="date" id="statsDatePicker" class="date-picker" value="${data.date || today}">
                    <button class="btn-refresh" onclick="loadStats()">T·∫£i l·∫°i</button>
                </div>
            `;
            
            statsContainer.appendChild(statsHeader);
            
            // Cards t·ªïng quan
            const statsGrid = document.createElement('div');
            statsGrid.className = 'stats-grid';
            
            // Helper for pretty numbers
            function fmt(n) { return (typeof n === 'number') ? n.toLocaleString('vi-VN') : n; }

            const completionPercent = data.totalOrders > 0 ? Math.round((data.totalCompleted || 0) / data.totalOrders * 100) : 0;

            statsGrid.innerHTML = `
                <div class="stats-card">
                    <div class="stats-card-header"><div class="stats-card-title"><span class="stat-icon employees">üë•</span> T·ªïng nh√¢n vi√™n</div></div>
                    <div class="stats-card-value">${fmt(data.totalEmployees)}<span class="muted"> ho·∫°t ƒë·ªông</span></div>
                    <div class="stats-card-detail">S·ªë nh√¢n vi√™n tham gia ki·ªÉm ƒë∆°n h√¥m nay</div>
                </div>
                <div class="stats-card">
                    <div class="stats-card-header"><div class="stats-card-title"><span class="stat-icon orders">üì¶</span> T·ªïng ƒë∆°n h√†ng</div></div>
                    <div class="stats-card-value">${fmt(data.totalOrders)}<span class="muted"> t·ªïng</span></div>
                    <div class="stats-card-detail">ƒê√£ ho√†n th√†nh: ${fmt(data.totalCompleted || 0)} ¬∑ Ch∆∞a ho√†n th√†nh: ${fmt((data.totalOrders || 0) - (data.totalCompleted || 0))}</div>
                    <div class="card-progress"><div class="fill" style="width:${completionPercent}%;"></div></div>
                </div>
                <div class="stats-card">
                    <div class="stats-card-header"><div class="stats-card-title"><span class="stat-icon items">üì¶</span> T·ªïng s·∫£n ph·∫©m</div></div>
                    <div class="stats-card-value">${fmt(data.totalItems)}<span class="muted"> m·ª•c</span></div>
                    <div class="stats-card-detail">S·ªë s·∫£n ph·∫©m ƒë√£ qu√©t trong ng√†y</div>
                </div>
            `;
            
            statsContainer.appendChild(statsGrid);
            
            // B·∫£ng chi ti·∫øt theo nh√¢n vi√™n
            if (data.employeeStats && data.employeeStats.length > 0) {
                const table = document.createElement('table');
                table.className = 'stats-table';

                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Nh√¢n vi√™n</th>
                            <th>S·ªë ƒë∆°n h√†ng</th>
                            <th>S·ªë s·∫£n ph·∫©m</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${data.employeeStats.map((emp) => {
                            return `
                                <tr>
                                    <td style="font-weight: 600; color: #3b82f6;">${escapeHtml(emp.employeeName)}</td>
                                    <td style="text-align: center; font-weight: 600;">${fmt(emp.totalOrders)}</td>
                                    <td style="text-align: center;">${fmt(emp.totalItems)}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                `;

                statsContainer.appendChild(table);
            } else {
                const noDataMessage = document.createElement('div');
                noDataMessage.style.cssText = `
                    text-align: center; 
                    padding: 40px; 
                    color: #64748b; 
                    background: #f8fafc; 
                    border-radius: 8px; 
                    margin-top: 20px;
                `;
                noDataMessage.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 16px;">üì≠</div>
                    <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">Kh√¥ng c√≥ d·ªØ li·ªáu</div>
                    <div>Kh√¥ng c√≥ ƒë∆°n h√†ng n√†o ƒë∆∞·ª£c ho√†n th√†nh trong ng√†y n√†y</div>
                `;
                statsContainer.appendChild(noDataMessage);
            }
            
            body.appendChild(statsContainer);
            
            // Event listener cho date picker
            const datePicker = document.getElementById('statsDatePicker');
            if (datePicker) {
                datePicker.addEventListener('change', loadStats);
            }
        }
        
        // H√†m hi·ªÉn th·ªã l·ªói th·ªëng k√™
        function displayStatsError(errorMessage) {
            const body = document.getElementById('rows');
            body.innerHTML = '';
            
            const errorContainer = document.createElement('div');
            errorContainer.className = 'stats-container';
            
            errorContainer.innerHTML = `
                <div class="error-stats">
                    <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                    <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">L·ªói t·∫£i th·ªëng k√™</div>
                    <div style="color: #64748b;">${escapeHtml(errorMessage)}</div>
                    <button class="btn" style="margin-top: 20px;" onclick="loadStats()">üîÑ Th·ª≠ l·∫°i</button>
                </div>
            `;
            
            body.appendChild(errorContainer);
        }

        // H√†m load d·ªØ li·ªáu real-time t·ª´ database cho ch·∫ø ƒë·ªô view
        async function loadAllOrdersFromDB(showStatus = true, source = 'manual') {
            try {
                if (showStatus) {
                    setStatus('ƒêang t·∫£i d·ªØ li·ªáu real-time...', '');
                }
                const response = await fetch('/api/orders', {
                    credentials: 'include',
                    headers: { 'Authorization': 'Bearer ' + getAuthToken() }
                });
                const result = await response.json();
                
                
                // Handle different response formats
                let orders = [];
                if (result.success && result.data && result.data.orders) {
                    // Standard format: {success: true, data: {orders: [...]}}
                    orders = result.data.orders;
                } else if (result.isCombined !== undefined && result.sources) {
                    // Alternative format: {isCombined: false, sources: [...]}
                    orders = result.sources || [];
                } else if (Array.isArray(result)) {
                    // Direct array format: [...]
                    orders = result;
                } else if (result.data && Array.isArray(result.data)) {
                    // Direct data array: {data: [...]}
                    orders = result.data;
                }
                
                if (orders && orders.length > 0) {
                    const oldOrdersCount = cacheOrders.length;
                    const newOrders = orders;
                    
                    
                    // Ki·ªÉm tra xem c√≥ thay ƒë·ªïi kh√¥ng
                    const hasChanges = oldOrdersCount !== newOrders.length || 
                                     JSON.stringify(cacheOrders.map(o => ({ id: o._id, verified: o.verified, block: o.block }))) !== 
                                     JSON.stringify(newOrders.map(o => ({ id: o._id, verified: o.verified, block: o.block })));
                    
                    setCacheOrders(newOrders, source);
                    
                    // N·∫øu ƒëang c√≥ search active, √°p d·ª•ng l·∫°i search
                    if (window.currentSearchValue && window.displayFilteredOrders) {
                        const searchInput = document.getElementById('searchMaVanDon');
                        if (searchInput && searchInput.value.trim()) {
                            const filteredOrders = newOrders.filter(order => 
                                order.maVanDon.toLowerCase().includes(searchInput.value.trim().toLowerCase())
                            );
                            window.displayFilteredOrders(filteredOrders, searchInput.value.trim());
                        } else {
                            renderOrders();
                        }
                    } else {
                        renderOrders();
                    }
                    
                    if (hasChanges) {
                        
                        if (showStatus) {
                            setStatus(`ƒê√£ c·∫≠p nh·∫≠t ${cacheOrders.length} ƒë∆°n h√†ng t·ª´ database (real-time)`, 'ok');
                        }
                    } else if (showStatus) {
                        setStatus(`ƒê√£ t·∫£i ${cacheOrders.length} ƒë∆°n h√†ng t·ª´ database (real-time)`, 'ok');
                    }
                } else {
                    
                    if (showStatus) {
                        setStatus(`Kh√¥ng c√≥ d·ªØ li·ªáu ƒë∆°n h√†ng ƒë·ªÉ hi·ªÉn th·ªã. Response format: ${JSON.stringify(result).substring(0, 100)}...`, 'err');
                    ensureInputFocus();
                    }
                }
            } catch (error) {
                if (showStatus) {
                    setStatus('L·ªói k·∫øt n·ªëi database: ' + error.message, 'err');
                    ensureInputFocus();
                }
            }
        }


        // H√†m t·ª± ƒë·ªông refresh khi c√≥ thao t√°c tr√™n database (ch·ªâ khi ·ªü ch·∫ø ƒë·ªô view)
        function autoRefreshIfInViewMode() {
            if (activeView === 'view') {
                lastPollingTime = Date.now();
                loadAllOrdersFromDB();
            }
        }

        // H√†m b·∫Øt ƒë·∫ßu polling ƒë·ªãnh k·ª≥ ƒë·ªÉ ph√°t hi·ªán thay ƒë·ªïi t·ª´ nh√¢n vi√™n kh√°c
        function startPolling() {
            stopPolling();
            pollingInterval = setInterval(() => {
                if (activeView === 'view') {
                    // N·∫øu ƒëang c√≥ search/filter active, refresh search thay v√¨ load t·∫•t c·∫£
                    if (window.currentSearchValue || window.hasActiveSearch) {
                        const searchInput = document.getElementById('searchMaVanDon');
                        const dateFromInput = document.getElementById('dateFrom');
                        const dateToInput = document.getElementById('dateTo');
                        
                        const hasSearchValue = searchInput && searchInput.value.trim();
                        const hasDateFrom = dateFromInput && dateFromInput.value;
                        const hasDateTo = dateToInput && dateToInput.value;
                        
                        if (hasSearchValue || hasDateFrom || hasDateTo) {
                            // C√≥ search/filter active, g·ªçi l·∫°i performSearch ƒë·ªÉ refresh
                            if (window.performSearch) {
                                // L·∫•y page hi·ªán t·∫°i t·ª´ window ho·∫∑c pagination
                                let currentSearchPage = window.currentSearchPage || 1;
                                const pager = document.getElementById('order-pager');
                                if (pager) {
                                    const pageInfo = pager.querySelector('span');
                                    if (pageInfo) {
                                        const match = pageInfo.textContent.match(/Trang (\d+)/);
                                        if (match) currentSearchPage = parseInt(match[1], 10);
                                    }
                                }
                                // G·ªçi performSearch v·ªõi page hi·ªán t·∫°i ƒë·ªÉ refresh m√† kh√¥ng reset v·ªÅ trang 1
                                window.performSearch(currentSearchPage);
                            }
                        } else {
                            // Kh√¥ng c√≥ search, load t·∫•t c·∫£
                            loadAllOrdersFromDB(false, 'polling');
                        }
                    } else {
                        // Kh√¥ng c√≥ search active, load t·∫•t c·∫£
                        loadAllOrdersFromDB(false, 'polling');
                    }
                }
            }, 5000);
        }

        // H√†m d·ª´ng polling
        function stopPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        }


        // H√†m ki·ªÉm tra xem code c√≥ v·∫ª nh∆∞ m√£ v·∫≠n ƒë∆°n kh√¥ng
        function looksLikeVanDon(code) {
            const dashCount = (code.match(/-/g) || []).length;
            return dashCount === 0;
        }

        // H√†m ki·ªÉm tra input c√≥ h·ª£p l·ªá kh√¥ng
        function isValidInput(code) {
            // Ki·ªÉm tra ƒë·ªô d√†i t·ªëi thi·ªÉu
            if (!code || code.length < 3) return false;
            
            // Ki·ªÉm tra k√Ω t·ª± ƒë·∫∑c bi·ªát kh√¥ng h·ª£p l·ªá
            const invalidChars = /[<>:"/\\|?*]/;
            if (invalidChars.test(code)) return false;
            
            // Ki·ªÉm tra ch·ªâ ch·ª©a kho·∫£ng tr·∫Øng
            if (code.trim().length === 0) return false;
            
            return true;
        }

        // ========== STATE MACHINE HANDLER ==========

        async function handleEnter(value) {
            const code = value.trim();
            
            if (!code) {
                    return;
                }
                    
            // ƒê√≥ng modal n·∫øu ƒëang hi·ªÉn th·ªã
                                        hideModal();
            
            // Ch·ªâ s·ª≠ d·ª•ng State Machine khi ·ªü ch·∫ø ƒë·ªô check
            const shouldUseStateMachine = (activeView === 'check' || userRole === 'packer');
            
            try {
                if (shouldUseStateMachine) {
                    // S·ª≠ d·ª•ng State Machine Pattern
                    await orderCheckSM.handleInput(code);
                            } else {
                    await handleEnterLegacy(code);
                            }
                        } catch (error) {
                setStatus(`L·ªói x·ª≠ l√Ω input: ${error.message}`, 'err');
            }
        }
        
        // Logic c≈© cho c√°c ch·∫ø ƒë·ªô kh√¥ng ph·∫£i check
        async function handleEnterLegacy(code) {
            if (isLoading) return;
            
            // Ki·ªÉm tra input c√≥ h·ª£p l·ªá kh√¥ng
            if (!isValidInput(code)) {
                setStatus('Input kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p l·∫°i.', 'err');
                        ensureInputFocus();
                        return;
                    }
                    
            isLoading = true;
            try {
                // Logic c≈© cho view mode - ch·ªâ hi·ªÉn th·ªã th√¥ng b√°o
                setStatus('Ch·∫ø ƒë·ªô view - kh√¥ng h·ªó tr·ª£ qu√©t', 'warn');
                        ensureInputFocus();
            } catch (e) {
                setStatus(e.message || 'C√≥ l·ªói x·∫£y ra', 'err');
                ensureInputFocus();
            } finally {
                isLoading = false;
            }
        }

        async function reloadCurrentVanDon() {
            if (!currentMaVanDon) return;
            const res = await fetch(`/api/orders/by-van-don/${encodeURIComponent(currentMaVanDon)}`, {
                credentials: 'include',
                headers: { 'Authorization': 'Bearer ' + getAuthToken() }
            });
            const data = await res.json();
            if (data.success) {
                setCacheOrders(data.data.orders || [], 'loadAllOrders');
            }
        }

        async function loadAllOrders() {
            try {
                const token = typeof getAuthToken === 'function' ? getAuthToken() : (sessionStorage.getItem('jwt') || '');
                const headers = token ? { 'Authorization': 'Bearer ' + token } : {};
                const res = await fetch('/api/orders?limit=1000', { credentials: 'include', headers });
                const data = await res.json();
                if (data.success && data.data && data.data.orders) {
                    setCacheOrders(data.data.orders, 'loadAllOrders');
                    renderOrders();
                }
            } catch (e) {
                // ignore
            }
        }

        function escapeHtml(str) {
            return String(str)
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#039;');
        }

        async function resetPage() {
            if (currentMaVanDon) {
                try {
                    await fetch('/api/orders/unblock-van-don', {
                        credentials: 'include',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + getAuthToken()
                        },
                        body: JSON.stringify({ maVanDon: currentMaVanDon })
                    });
                } catch {}
            }
            currentMaVanDon = '';
            cacheOrders = [];
            document.getElementById('maVanDonTag').textContent = 'Ch∆∞a ch·ªçn';
            setStatus('ƒê√£ h·ªßy kh√≥a ƒë∆°n hi·ªán t·∫°i. Nh·∫≠p m√£ v·∫≠n ƒë∆°n m·ªõi.', '');
            renderOrders();
            ensureInputFocus();
        }

        window.addEventListener('beforeunload', async () => {
            // D·ª´ng polling
            stopPolling();
            
            // Unblock ƒë∆°n h√†ng n·∫øu c√≥
            if (currentMaVanDon) {
                try {
                    navigator.sendBeacon && navigator.sendBeacon('/api/orders/unblock-van-don', new Blob([JSON.stringify({ maVanDon: currentMaVanDon })], { type: 'application/json' }));
                } catch {}
            }
        });

        // H√†m unlock ƒë∆°n hi·ªán t·∫°i v·ªõi error handling
        async function unlockCurrentOrder(maVanDonToUnlock = null) {
            const orderToUnlock = maVanDonToUnlock || currentMaVanDon;
            
            if (!orderToUnlock) {
                return false;
            }
            
            try {
                
                const response = await fetch('/api/orders/unblock-van-don', {
                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + getAuthToken()
                    },
                    body: JSON.stringify({ maVanDon: orderToUnlock })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    setStatus(`ƒê√£ m·ªü kh√≥a ƒë∆°n ${orderToUnlock}`, 'ok');
                    return true;
                } else {
                    setStatus(`L·ªói m·ªü kh√≥a ƒë∆°n ${orderToUnlock}: ${result.message}`, 'error');
                    return false;
                }
            } catch (error) {
                setStatus(`L·ªói m·ªü kh√≥a ƒë∆°n ${orderToUnlock}: ${error.message}`, 'error');
                return false;
            }
        }

        async function switchView(view) {
            // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô check v√† chuy·ªÉn sang view kh√°c, unlock ƒë∆°n hi·ªán t·∫°i
            if (activeView === 'check' && view !== 'check' && currentMaVanDon) {
                // L∆∞u l·∫°i currentMaVanDon tr∆∞·ªõc khi reset
                const currentOrderToUnlock = currentMaVanDon;
                
                // Reset tr·∫°ng th√°i ƒë∆°n hi·ªán t·∫°i
                currentMaVanDon = '';
                cacheOrders = [];
                currentVanDonStatus = null;
                orderCheckState = 'idle';
                scannedItems = [];
                waitingForNewOrder = false;
                document.getElementById('maVanDonTag').textContent = 'Ch∆∞a ch·ªçn';
                
                // Reset State Machine
                if (orderCheckSM) {
                    orderCheckSM.reset();
                }
                
                // Unlock ƒë∆°n tr√™n server
                await unlockCurrentOrder(currentOrderToUnlock);
                
                // C·∫≠p nh·∫≠t giao di·ªán
                renderQueue();
                renderOrders();
            }
            
            activeView = view;
            if (userRole === 'checker') {
                document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
                const activeBtn = document.getElementById(view + 'Btn');
                if (activeBtn) activeBtn.classList.add('active');
                
                // D·ª´ng polling n·∫øu kh√¥ng ·ªü ch·∫ø ƒë·ªô view
                if (view !== 'view') {
                    stopPolling();
                }
                
                // N·∫øu chuy·ªÉn sang ch·∫ø ƒë·ªô check, clear t·∫•t c·∫£ search state
                if (view === 'check') {
                    // Clear search state
                    window.currentSearchValue = '';
                    window.hasActiveSearch = false;
                    
                    // Clear search inputs n·∫øu c√≥
                    const searchInput = document.getElementById('searchMaVanDon');
                    if (searchInput) searchInput.value = '';
                    
                    const dateFromInput = document.getElementById('dateFrom');
                    if (dateFromInput) dateFromInput.value = '';
                    
                    const dateToInput = document.getElementById('dateTo');
                    if (dateToInput) dateToInput.value = '';
                    
                    // Clear URL params
                    const url = new URL(window.location.href);
                    url.searchParams.delete('dateFrom');
                    url.searchParams.delete('dateTo');
                    url.searchParams.delete('maVanDon');
                    window.history.replaceState({}, '', url);
                    
                    // N·∫øu ch∆∞a c√≥ ƒë∆°n h√†ng ƒë∆∞·ª£c ch·ªçn, clear cacheOrders
                    if (!currentMaVanDon) {
                        cacheOrders = [];
                    }
                }
            }
            const input = document.getElementById('codeInput');
            const spin = document.getElementById('spin');
            const uploadPanel = document.getElementById('uploadPanel');
            const uploadMasterPanel = document.getElementById('uploadMasterPanel');
            const uploadComboPanel = document.getElementById('uploadComboPanel');
            const rows = document.getElementById('rows');
            const inputWrap = document.getElementById('inputWrap');
            const metaWrap = document.getElementById('metaWrap');
            if (view === 'upload') {
                uploadPanel.style.display = '';
                uploadMasterPanel.style.display = '';
                uploadComboPanel.style.display = '';
                rows.style.display = 'none';
                inputWrap.style.display = 'none';
                metaWrap.style.display = 'none';
            } else if (view === 'check') {
                // Only input + result
                uploadPanel.style.display = 'none';
                uploadMasterPanel.style.display = 'none';
                uploadComboPanel.style.display = 'none';
                rows.style.display = '';
                inputWrap.style.display = '';
                metaWrap.style.display = '';
                // ƒë·∫£m b·∫£o danh s√°ch ƒëang hi·ªÉn th·ªã ƒë√∫ng theo ƒë∆°n ƒëang ho·∫°t ƒë·ªông
                if (currentMaVanDon && queueMap.has(currentMaVanDon)) {
                    const info = queueMap.get(currentMaVanDon);
                    cacheOrders = info.orders || [];
                }
                
                // ƒê·∫£m b·∫£o State Machine ƒë∆∞·ª£c kh√¥i ph·ª•c ƒë√∫ng c√°ch
                if (orderCheckSM && !orderCheckSM.currentOrder && currentMaVanDon) {
                    // N·∫øu c√≥ ƒë∆°n hi·ªán t·∫°i nh∆∞ng State Machine ch∆∞a c√≥, kh√¥i ph·ª•c State Machine
                    orderCheckSM.currentOrder = { maVanDon: currentMaVanDon };
                    orderCheckSM.cacheOrders = cacheOrders || [];
                    orderCheckSM.state = orderCheckState === 'idle' ? orderCheckSM.CheckStates.IDLE : orderCheckSM.CheckStates.ORDER_ACTIVE;
                    orderCheckSM.updateUI();
                }
                
                input.placeholder = currentMaVanDon ? 'Nh·∫≠p m√£ h√†ng r·ªìi nh·∫•n Enter' : 'Nh·∫≠p m√£ v·∫≠n ƒë∆°n r·ªìi nh·∫•n Enter';
                setStatus(currentMaVanDon ? 'Nh·∫≠p m√£ h√†ng ƒë·ªÉ qu√©t.' : 'Nh·∫≠p m√£ v·∫≠n ƒë∆°n ƒë·ªÉ t·∫£i ƒë∆°n v√† kh√≥a ƒë∆°n.', '');
                
                // Render l·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng hi·ªÉn th·ªã d·ªØ li·ªáu search c≈©
                renderOrders();
            } else if (view === 'cancelled') {
                // cancelled: hi·ªÉn th·ªã danh s√°ch ƒë∆°n h·ªßy
                uploadPanel.style.display = 'none';
                uploadMasterPanel.style.display = 'none';
                uploadComboPanel.style.display = 'none';
                rows.style.display = '';
                inputWrap.style.display = 'none';
                metaWrap.style.display = '';
                // Load d·ªØ li·ªáu ƒë∆°n h·ªßy
                loadCancelledOrders();
                setStatus('', '');
            } else if (view === 'stats') {
                // stats: hi·ªÉn th·ªã th·ªëng k√™ theo nh√¢n vi√™n theo ng√†y
                uploadPanel.style.display = 'none';
                uploadMasterPanel.style.display = 'none';
                uploadComboPanel.style.display = 'none';
                rows.style.display = '';
                inputWrap.style.display = 'none';
                metaWrap.style.display = '';
                // Load v√† hi·ªÉn th·ªã th·ªëng k√™
                loadStats();
                setStatus('', '');
            } else {
                // view: only list all orders - load real-time data from database
                uploadPanel.style.display = 'none';
                uploadMasterPanel.style.display = 'none';
                uploadComboPanel.style.display = 'none';
                rows.style.display = '';
                inputWrap.style.display = 'none';
                metaWrap.style.display = '';
                // Load d·ªØ li·ªáu real-time t·ª´ database (ch·ªâ g·ªçi 1 function)
                loadAllOrdersFromDB();
                setStatus('', '');
                // B·∫Øt ƒë·∫ßu polling ƒë·ªÉ ph√°t hi·ªán thay ƒë·ªïi t·ª´ nh√¢n vi√™n kh√°c
                startPolling();
            }
            ensureInputFocus();
        }

        window.addEventListener('DOMContentLoaded', async () => {
            // Diagnostic overlay for login/token issues (ƒë√£ ·∫©n)
            function showDiagnostics(token, meResult, error) {
                // Diagnostic ƒë√£ ƒë∆∞·ª£c ·∫©n ƒë·ªÉ giao di·ªán s·∫°ch s·∫Ω h∆°n
                return;
            }

            // Run diagnostics before ensureChecker
            let diagToken = getAuthToken();
            let diagMe = null;
            let diagErr = null;
            try {
                const headers = diagToken ? { 'Authorization': 'Bearer ' + diagToken } : {};
                const res = await fetch('/api/me', { credentials: 'include', headers });
                diagMe = await res.json();
            } catch (e) { diagErr = e.message; }
            showDiagnostics(diagToken, diagMe, diagErr);

            const ok = await ensureChecker();
            if (!ok) return;
            // PACKER: ·∫©n sidebar, kh√¥ng c·∫ßn ch·ªçn ch·ª©c nƒÉng
            if (userRole === 'packer') {
                const sidebar = document.getElementById('sidebar');
                const layout = document.getElementById('layout');
                if (sidebar) sidebar.style.display = 'none';
                if (layout) layout.style.gridTemplateColumns = '1fr';
                const hint = document.getElementById('hint');
                if (hint) hint.textContent = '- Nh·∫≠p m√£ v·∫≠n ƒë∆°n (Enter) ƒë·ªÉ t·∫£i ƒë∆°n, sau ƒë√≥ nh·∫≠p m√£ h√†ng ƒë·ªÉ qu√©t. M·ªçi thao t√°c trong 1 √¥ nh·∫≠p.';
                // Th√™m n√∫t logout cho packer n·∫øu ch∆∞a c√≥ (ƒë√£ ·∫©n v√¨ c√≥ n√∫t ·ªü header)
                let logoutPacker = document.getElementById('logoutBtnPacker');
                if (!logoutPacker) {
                    logoutPacker = document.createElement('button');
                    logoutPacker.id = 'logoutBtnPacker';
                    logoutPacker.textContent = 'ƒêƒÉng xu·∫•t';
                    logoutPacker.className = 'btn danger';
                    logoutPacker.style.margin = '18px 0';
                    logoutPacker.style.display = 'none'; // ·∫®n n√∫t logout packer
                    document.body.appendChild(logoutPacker);
                }
                logoutPacker.style.display = 'none'; // ƒê·∫£m b·∫£o ·∫©n
                logoutPacker.onclick = async () => {
                    showConfirmModal(
                        'X√°c nh·∫≠n ƒëƒÉng xu·∫•t',
                        'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ƒëƒÉng xu·∫•t?\nƒê∆°n h√†ng hi·ªán t·∫°i s·∫Ω ƒë∆∞·ª£c m·ªü kh√≥a.',
                        async () => {
                            try {
                                // G·ª≠i y√™u c·∫ßu m·ªü kh√≥a cho ƒë∆°n hi·ªán t·∫°i
                                if (currentMaVanDon) {
                                    await fetch('/api/orders/unblock-van-don', {
                                method: 'POST',
                                credentials: 'include',
                                headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + getAuthToken() },
                                        body: JSON.stringify({ maVanDon: currentMaVanDon })
                                    });
                                }
                        } catch {}
                        await fetch('/api/logout', { method: 'POST', credentials: 'include', headers: { 'Authorization': 'Bearer ' + getAuthToken() } });
                        sessionStorage.removeItem('auth_token');
                        sessionStorage.removeItem('checkerAuthToken');
                        location.href = '/login';
                    }
                    );
                };
            }
            const input = document.getElementById('codeInput');
            ensureInputFocus();
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const val = input.value;
                    input.value = '';
                    
                    // L∆∞u user behaviour cho vi·ªác input
                    saveUserBehaviour('keyboard', `Input: ${val}`, {
                        input: val,
                        action: 'enter_key',
                        timestamp: new Date().toISOString()
                    });
                    
                    handleEnter(val);
                }
            });
            // V√†o trang: checker -> Xem ƒë∆°n h√†ng; packer -> Check ƒë∆°n (m·ªôt ch·ª©c nƒÉng duy nh·∫•t)
            if (userRole === 'checker') {
                await switchView('view');
            } else {
                await switchView('check');
            }
            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) resetBtn.addEventListener('click', resetPage);
            
            // X√≥a event listener c≈© c·ªßa n√∫t logout v√¨ ƒë√£ c√≥ trong header
            /*
            document.getElementById('logoutBtn').addEventListener('click', async () => {
                showConfirmModal(
                    'X√°c nh·∫≠n ƒëƒÉng xu·∫•t',
                    'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ƒëƒÉng xu·∫•t?\nƒê∆°n h√†ng hi·ªán t·∫°i s·∫Ω ƒë∆∞·ª£c m·ªü kh√≥a.',
                    async () => {
                        try {
                            // G·ª≠i y√™u c·∫ßu m·ªü kh√≥a cho ƒë∆°n hi·ªán t·∫°i
                            if (currentMaVanDon) {
                                await fetch('/api/orders/unblock-van-don', {
                                method: 'POST',
                                credentials: 'include',
                                headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + getAuthToken() },
                                    body: JSON.stringify({ maVanDon: currentMaVanDon })
                                });
                            }
                    } catch {}
                        
                        // Ng·∫Øt k·∫øt n·ªëi COM port n·∫øu ƒëang k·∫øt n·ªëi
                        if (currentComPort) {
                            try {
                                
                                // X√≥a b·∫£n ghi port c·ª• th·ªÉ
                                try {
                                    await fetch('/api/delete-port', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ comPort: currentComPort })
                                    });
                                } catch (error) {
                                }
                                
                                // ƒê√≥ng COM port
                                if (currentPort) {
                                    await currentPort.close();
                                }
                                
                                // Stop heartbeat
                                stopHeartbeat();
                                
                                // Reset tr·∫°ng th√°i
                                isComConnected = false;
                                currentComPort = null;
                                currentPort = null;
                                isListening = false;
                                
                            } catch (error) {
                            }
                        }
                        
                        // X√≥a ho√†n to√†n t·∫•t c·∫£ b·∫£n ghi port c·ªßa user hi·ªán t·∫°i (fallback)
                        try {
                            const currentUser = getCurrentUsername();
                            if (currentUser) {
                                // G·ªçi API ƒë·ªÉ x√≥a ho√†n to√†n t·∫•t c·∫£ b·∫£n ghi port c·ªßa user hi·ªán t·∫°i
                                const response = await fetch('/api/delete-all-user-ports', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ userId: currentUser })
                                });
                                const result = await response.json();
                            }
                        } catch (error) {
                        }
                        
                        // Reset tr·∫°ng th√°i
                        orderCheckState = 'idle';
                        scannedItems = [];
                        currentVanDonStatus = null;
                        waitingForNewOrder = false;
                    await fetch('/api/logout', { method: 'POST', credentials: 'include', headers: { 'Authorization': 'Bearer ' + getAuthToken() } });
                    location.href = '/login';
                }
                );
            });
            */
            
            if (userRole === 'checker') {
                // ƒê·∫£m b·∫£o c√°c n√∫t ch·ª©c nƒÉng lu√¥n ho·∫°t ƒë·ªông
                const uploadBtn = document.getElementById('uploadBtn');
                const checkBtn = document.getElementById('checkBtn');
                const viewBtn = document.getElementById('viewBtn');
                const filePicker = document.getElementById('filePicker');
                const drop = document.getElementById('dropzone');
                const fileNameEl = document.getElementById('fileName');
                const progressBar = document.getElementById('uploadBar');
                const toast = document.getElementById('toast');
                // Upload MasterData
                const fileMasterPicker = document.getElementById('fileMasterPicker');
                const fileMasterName = document.getElementById('fileMasterName');
                const uploadMasterBar = document.getElementById('uploadMasterBar');
                const doUploadMaster = document.getElementById('doUploadMaster');
                
                // Upload ComboData
                const fileComboPicker = document.getElementById('fileComboPicker');
                const fileComboName = document.getElementById('fileComboName');
                const uploadComboBar = document.getElementById('uploadComboBar');
                const doUploadCombo = document.getElementById('doUploadCombo');
                const fixComboData = document.getElementById('fixComboData');
                function showToast(msg, ok) {
                    toast.textContent = msg;
                    toast.style.background = ok ? '#065f46' : '#7f1d1d';
                    toast.classList.add('show');
                    setTimeout(() => toast.classList.remove('show'), 2500);
                }
                function setProgress(pct) { progressBar.style.width = Math.max(0, Math.min(100, pct)) + '%'; }
                async function uploadFileWithProgress(file) {
                    const form = new FormData();
                    form.append('file', file);
                    let token = '';
                    if (typeof getAuthToken === 'function') token = getAuthToken();
                    else if (sessionStorage.getItem('jwt')) token = sessionStorage.getItem('jwt');
                    try {
                        const res = await fetch('/api/checker/upload', {
                            method: 'POST',
                            headers: token ? { 'Authorization': 'Bearer ' + token } : {},
                            body: form
                        });
                        if (!res.ok) {
                            const err = await res.json().catch(()=>({message:'L·ªói server'}));
                            throw new Error(err.message || 'Upload th·∫•t b·∫°i');
                        }
                        return await res.json();
                    } catch (e) {
                        return { success: false, message: 'L·ªói upload: ' + (e.message || e) };
                    }
                }
                viewBtn.addEventListener('click', async () => await switchView('view'));
                cancelledBtn.addEventListener('click', async () => await switchView('cancelled'));
                statsBtn.addEventListener('click', async () => await switchView('stats'));
                uploadBtn.addEventListener('click', async () => await switchView('upload'));
                checkBtn.addEventListener('click', async () => await switchView('check'));
                
                
                filePicker.addEventListener('change', async (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (!file) return;
                    fileNameEl.textContent = 'ƒê√£ ch·ªçn: ' + file.name;
                });
                // Explicit Upload button inside panel
                const uploadActionBtn = document.getElementById('doUpload');
                if (uploadActionBtn) uploadActionBtn.addEventListener('click', () => {
                    if (!filePicker.files || !filePicker.files[0]) {
                        setStatus('Vui l√≤ng ch·ªçn ho·∫∑c k√©o th·∫£ t·ªáp tr∆∞·ªõc khi upload.', 'warn');
                        ensureInputFocus();
                        return;
                    }
                    uploadActionBtn.disabled = true;
                    setProgress(0);
                    document.querySelector('.progress-line').style.display = '';
                    setStatus('ƒêang t·∫£i file l√™n...', '');
                    let loadingInterval = null;
                    let loadingStep = 0;
                    function showPendingEffect() {
                        loadingInterval = setInterval(() => {
                            loadingStep = (loadingStep + 1) % 4;
                            setStatus('ƒêang x·ª≠ l√Ω d·ªØ li·ªáu' + '.'.repeat(loadingStep), '');
                            ensureInputFocus();
                        }, 700);
                    }
                    showPendingEffect();
                    (async () => {
                        try {
                            const result = await uploadFileWithProgress(filePicker.files[0]);
                            clearInterval(loadingInterval);
                            setStatus('ƒêang ho√†n t·∫•t...', '');
                            setTimeout(async () => {
                                if (result.success) {
                                    setStatus(result.message || 'Upload th√†nh c√¥ng', 'ok');
                                    ensureInputFocus();
                                    
                                    // Hi·ªÉn th·ªã modal th√¥ng b√°o upload th√†nh c√¥ng
                                    showSuccessModal(
                                        'Upload th√†nh c√¥ng!',
                                        result.message || 'D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n th√†nh c√¥ng.\nS·∫µn s√†ng ƒë·ªÉ ki·ªÉm tra.',
                                        3000
                                    );
                                    
                                    // Hi·ªÉn th·ªã k·∫øt qu·∫£ chi ti·∫øt
                                    if (result.data && result.data.errors && result.data.errors.length) {
                                        let errHtml = '<div style="color:#991b1b;font-size:14px;margin-top:8px;">C√≥ l·ªói x·∫£y ra:</div>';
                                        for (const err of result.data.errors) {
                                            errHtml += `<div>- ${escapeHtml(err)}</div>`;
                                        }
                                        document.getElementById('rows').innerHTML = errHtml;
                                    } else {
                                        document.getElementById('rows').innerHTML = '<div style="color:#065f46;font-size:14px;margin-top:8px;">D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n th√†nh c√¥ng. S·∫µn s√†ng ƒë·ªÉ ki·ªÉm tra.</div>';
                                    }
                                    // T·ª± ƒë·ªông chuy·ªÉn sang tab Xem ƒë∆°n h√†ng
                                    await switchView('view');
                                    // Auto-refresh s·∫Ω ƒë∆∞·ª£c g·ªçi trong switchView('view')
                                } else {
                                    setStatus(result.message || 'Upload kh√¥ng th√†nh c√¥ng', 'err');
                                    ensureInputFocus();
                                    showErrorModal(
                                        'Upload th·∫•t b·∫°i',
                                        result.message || 'C√≥ l·ªói x·∫£y ra khi upload file. Vui l√≤ng th·ª≠ l·∫°i.'
                                    );
                                }
                            }, 300);
                        } catch (e) {
                            clearInterval(loadingInterval);
                            setStatus('C√≥ l·ªói x·∫£y ra khi t·∫£i l√™n', 'err');
                            ensureInputFocus();
                            showErrorModal(
                                'L·ªói upload',
                                'C√≥ l·ªói x·∫£y ra khi t·∫£i file l√™n server.\nVui l√≤ng ki·ªÉm tra k·∫øt n·ªëi v√† th·ª≠ l·∫°i.'
                            );
                        }
                    })();
                });
                const dropHandler = async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const files = e.dataTransfer.files;
                    if (files && files.length) {
                        filePicker.files = files;
                        fileNameEl.textContent = 'ƒê√£ ch·ªçn: ' + files[0].name;
                        uploadActionBtn.click();
                    }
                };
                drop.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); drop.classList.add('drag'); });
                drop.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); drop.classList.remove('drag'); });
                drop.addEventListener('drop', dropHandler);

                // Drag & Drop for ComboData
                const dropzoneCombo = document.getElementById('dropzoneCombo');
                if (dropzoneCombo) {
                    const dropHandlerCombo = async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const files = e.dataTransfer.files;
                        if (files && files.length) {
                            fileComboPicker.files = files;
                            fileComboName.textContent = 'ƒê√£ ch·ªçn: ' + files[0].name;
                        }
                    };
                    dropzoneCombo.addEventListener('dragover', (e) => { 
                        e.preventDefault(); 
                        e.stopPropagation(); 
                        dropzoneCombo.classList.add('drag'); 
                    });
                    dropzoneCombo.addEventListener('dragleave', (e) => { 
                        e.preventDefault(); 
                        e.stopPropagation(); 
                        dropzoneCombo.classList.remove('drag'); 
                    });
                    dropzoneCombo.addEventListener('drop', dropHandlerCombo);
                }

                // Upload MasterData
                if (fileMasterPicker) fileMasterPicker.addEventListener('change', async (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (!file) return;
                    fileMasterName.textContent = 'ƒê√£ ch·ªçn: ' + file.name;
                });
                if (doUploadMaster) doUploadMaster.addEventListener('click', () => {
                    if (!fileMasterPicker.files || !fileMasterPicker.files[0]) {
                        showToast('Vui l√≤ng ch·ªçn file MasterData!', false);
                        return;
                    }
                    doUploadMaster.disabled = true;
                    uploadMasterBar.style.width = '0%';
                    document.querySelectorAll('.progress-line')[1].style.display = '';
                    showToast('ƒêang t·∫£i MasterData...', true);
                    (async () => {
                        try {
                            const form = new FormData();
                            form.append('file', fileMasterPicker.files[0]);
                            const token = getAuthToken();
                            
                            const res = await fetch('/api/checker/upload-masterdata', {
                                method: 'POST',
                                headers: {
                                    'Authorization': 'Bearer ' + token
                                },
                                body: form
                            });
                            uploadMasterBar.style.width = '100%';
                            const result = await res.json();
                            showToast(result.message || 'Upload MasterData th√†nh c√¥ng', result.success);
                            fileMasterPicker.value = '';
                            fileMasterName.textContent = '';
                        } catch (err) {
                            showToast('L·ªói upload MasterData!', false);
                        }
                        document.querySelectorAll('.progress-line')[1].style.display = 'none';
                        doUploadMaster.disabled = false;
                    })();
                });
                
                // Upload ComboData
                if (fileComboPicker) fileComboPicker.addEventListener('change', async (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (!file) return;
                    fileComboName.textContent = 'ƒê√£ ch·ªçn: ' + file.name;
                });
                
                if (doUploadCombo) doUploadCombo.addEventListener('click', () => {
                    if (!fileComboPicker.files || !fileComboPicker.files[0]) {
                        showToast('Vui l√≤ng ch·ªçn file ComboData!', false);
                        return;
                    }
                    doUploadCombo.disabled = true;
                    uploadComboBar.style.width = '0%';
                    document.querySelectorAll('.progress-line')[2].style.display = '';
                    showToast('ƒêang t·∫£i ComboData...', true);
                    (async () => {
                        try {
                            const form = new FormData();
                            form.append('file', fileComboPicker.files[0]);
                            let token = '';
                            if (typeof getAuthToken === 'function') token = getAuthToken();
                            else if (sessionStorage.getItem('jwt')) token = sessionStorage.getItem('jwt');
                            const res = await fetch('/api/checker/upload-combodata', {
                                method: 'POST',
                                headers: token ? { 'Authorization': 'Bearer ' + token } : {},
                                body: form
                            });
                            uploadComboBar.style.width = '100%';
                            const result = await res.json();
                            showToast(result.message || 'Upload ComboData th√†nh c√¥ng', result.success);
                            fileComboPicker.value = '';
                            fileComboName.textContent = '';
                        } catch (err) {
                            showToast('L·ªói upload ComboData!', false);
                        }
                        document.querySelectorAll('.progress-line')[2].style.display = 'none';
                        doUploadCombo.disabled = false;
                    })();
                });

                // Fix ComboData
                if (fixComboData) fixComboData.addEventListener('click', async () => {
                    if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën fix ComboData collection? ƒêi·ªÅu n√†y s·∫Ω x√≥a index c≈© v√† t·∫°o index m·ªõi.')) {
                        return;
                    }
                    
                    fixComboData.disabled = true;
                    showToast('ƒêang fix ComboData collection...', true);
                    
                    try {
                        let token = '';
                        if (typeof getAuthToken === 'function') token = getAuthToken();
                        else if (sessionStorage.getItem('jwt')) token = sessionStorage.getItem('jwt');
                        
                        const res = await fetch('/api/checker/fix-combodata', {
                            method: 'POST',
                            headers: token ? { 'Authorization': 'Bearer ' + token } : {}
                        });
                        
                        const result = await res.json();
                        showToast(result.message || 'Fix ComboData th√†nh c√¥ng', result.success);
                        
                        if (result.success && result.indexes) {
                        }
                        
                    } catch (err) {
                        showToast('L·ªói fix ComboData!', false);
                    }
                    
                    fixComboData.disabled = false;
                });
            }
            
            // Kh·ªüi t·∫°o scanner info
            try {
                await loadMyScannerPermissions();
            } catch (error) {
            }
        });

        function showForbiddenOverlay() {
            let diag = document.getElementById('diagnosticOverlay');
            if (!diag) {
                diag = document.createElement('div');
                diag.id = 'diagnosticOverlay';
                diag.style.position = 'fixed';
                diag.style.top = '50%';
                diag.style.left = '50%';
                diag.style.transform = 'translate(-50%,-50%)';
                diag.style.zIndex = '9999';
                diag.style.background = '#fff';
                diag.style.border = '2px solid #ef4444';
                diag.style.borderRadius = '10px';
                diag.style.padding = '24px 32px';
                diag.style.fontSize = '16px';
                diag.style.color = '#b91c1c';
                diag.style.boxShadow = '0 2px 12px #ef444433';
                diag.style.maxWidth = '420px';
                diag.style.wordBreak = 'break-all';
                diag.innerHTML = `<b>L·ªói truy c·∫≠p (403)</b><br><br>B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p v√†o trang n√†y.<br>Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n.<br><br><button style='margin-top:12px;padding:8px 18px;border-radius:6px;background:#ef4444;color:#fff;border:none;cursor:pointer;' onclick='location.href="/login"'>ƒêƒÉng nh·∫≠p l·∫°i</button>`;
                document.body.appendChild(diag);
            }
        }

        // ==================== SCANNER INFO FUNCTIONS ====================
        
        // L·∫•y th√¥ng tin m√°y qu√©t ƒë∆∞·ª£c ph√¢n quy·ªÅn cho user hi·ªán t·∫°i
        async function loadMyScannerPermissions() {
            try {
                
                const response = await fetch('/api/me', {
                    credentials: 'include',
                    headers: {
                        'Authorization': 'Bearer ' + getAuthToken()
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // User info loaded successfully
                    
                    // T·∫°o scannerPermissions gi·∫£ ƒë·ªÉ hi·ªÉn th·ªã button
                    result.scannerPermissions = {
                        allowedScanners: ['COM_PORT_AVAILABLE'],
                        assignedScanner: 'COM_PORT_AVAILABLE',
                        port: 'COM_PORT_AVAILABLE'
                    };
                    
                    // T·∫°o danh s√°ch scanners gi·∫£ ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi displayScannerPermissions
                    const mockScanners = [{
                        scannerId: 'COM_PORT_AVAILABLE',
                        scannerName: 'M√°y qu√©t COM Port',
                        status: 'available',
                        assignedTo: result.username,
                        sessionId: null,
                        assignedAt: new Date().toISOString(),
                        expiresAt: null,
                        realPort: {
                            path: 'COM_PORT_AVAILABLE',
                            manufacturer: 'Unknown',
                            vendorId: null,
                            productId: null
                        },
                        isConnected: false,
                        portInfo: {
                            path: 'COM_PORT_AVAILABLE',
                            manufacturer: 'Unknown',
                            vendorId: null,
                            productId: null
                        },
                        isNewPort: true,
                        confidence: 100,
                        deviceType: 'scanner',
                        note: 'Click ƒë·ªÉ ch·ªçn thi·∫øt b·ªã COM port'
                    }];
                    
                    displayScannerPermissions(result, mockScanners);
                } else {
                }
            } catch (error) {
            }
        }

        // Hi·ªÉn th·ªã th√¥ng tin m√°y qu√©t ƒë∆∞·ª£c ph√¢n quy·ªÅn
        function displayScannerPermissions(userInfo, allScanners) {
            const noScannerInfo = document.getElementById('noScannerInfo');
            const scannerDetails = document.getElementById('scannerDetails');
            const allowedScannersSpan = document.getElementById('allowedScanners');
            const currentAssignedScannerSpan = document.getElementById('currentAssignedScanner');
            const assignedPortSpan = document.getElementById('assignedPort');

            // Ki·ªÉm tra conflict m√°y qu√©t
            if (userInfo.scannerConflict) {
                showToast(userInfo.scannerConflict.message, false);
                
                // Hi·ªÉn th·ªã th√¥ng b√°o conflict
                const conflictDiv = document.createElement('div');
                conflictDiv.style.cssText = 'margin-top: 10px; padding: 10px; background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; border-radius: 4px; font-size: 14px;';
                conflictDiv.innerHTML = `
                    <strong>‚ö†Ô∏è C·∫£nh b√°o:</strong><br>
                    ${userInfo.scannerConflict.message}<br>
                    <small>Li√™n h·ªá admin ƒë·ªÉ gi·∫£i quy·∫øt</small>
                `;
                
                const scannerInfo = document.getElementById('scannerInfo');
                scannerInfo.appendChild(conflictDiv);
            }

            // Ki·ªÉm tra xem user c√≥ quy·ªÅn m√°y qu√©t kh√¥ng
            if (!userInfo.scannerPermissions || !userInfo.scannerPermissions.allowedScanners || userInfo.scannerPermissions.allowedScanners.length === 0) {
                noScannerInfo.style.display = 'block';
                scannerDetails.style.display = 'none';
                return;
            }

            // Hi·ªÉn th·ªã th√¥ng tin m√°y qu√©t ƒë∆∞·ª£c ph√©p
            const allowedScannerNames = userInfo.scannerPermissions.allowedScanners.map(scannerId => {
                const scanner = allScanners.find(s => s.scannerId === scannerId);
                return scanner ? scanner.scannerName : scannerId;
            });

            allowedScannersSpan.textContent = allowedScannerNames.join(', ');

            // Hi·ªÉn th·ªã m√°y qu√©t hi·ªán t·∫°i ƒë∆∞·ª£c assign
            if (userInfo.scannerPermissions.assignedScanner) {
                const assignedScanner = allScanners.find(s => s.scannerId === userInfo.scannerPermissions.assignedScanner);
                currentAssignedScannerSpan.textContent = assignedScanner ? assignedScanner.scannerName : userInfo.scannerPermissions.assignedScanner;
                currentAssignedScannerSpan.style.color = '#28a745';
                currentAssignedScannerSpan.style.fontWeight = 'bold';
            } else {
                currentAssignedScannerSpan.textContent = 'Ch∆∞a ƒë∆∞·ª£c assign';
                currentAssignedScannerSpan.style.color = '#999';
            }

            // Hi·ªÉn th·ªã button k·∫øt n·ªëi COM port cho t·∫•t c·∫£ user (gi·ªëng debug-client.html)
            
            // Hi·ªÉn th·ªã th√¥ng tin
            assignedPortSpan.textContent = 'Click ƒë·ªÉ ch·ªçn thi·∫øt b·ªã';
            assignedPortSpan.style.color = '#007bff';
            assignedPortSpan.style.fontWeight = 'bold';

            noScannerInfo.style.display = 'none';
            scannerDetails.style.display = 'block';
            
        }

        // Hi·ªÉn th·ªã modal blocking khi ch∆∞a ƒë∆∞·ª£c ph√¢n quy·ªÅn m√°y qu√©t
        function showBlockingModal() {
            showModal({
                type: 'warning',
                title: '‚ö†Ô∏è Ch∆∞a c√≥ quy·ªÅn s·ª≠ d·ª•ng m√°y qu√©t',
                message: 'Admin ch∆∞a ph√¢n quy·ªÅn m√°y qu√©t COM cho b·∫°n.\n\nVui l√≤ng li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c c·∫•p quy·ªÅn s·ª≠ d·ª•ng m√°y qu√©t tr∆∞·ªõc khi th·ª±c hi·ªán c√¥ng vi·ªác.',
                buttons: [
                    {
                        text: 'L√†m m·ªõi trang',
                        class: 'primary',
                        onclick: () => {
                            location.reload();
                        }
                    },
                    {
                        text: 'ƒêƒÉng xu·∫•t',
                        class: 'secondary',
                        style: 'display: none;', // ·∫®n n√∫t logout trong modal
                        onclick: async () => {
                            await fetch('/api/logout', { method: 'POST', credentials: 'include' });
                            location.href = '/login';
                        }
                    }
                ]
            });

            // Disable t·∫•t c·∫£ input v√† n√∫t
            const input = document.getElementById('codeInput');
            if (input) input.disabled = true;
            
            const allButtons = document.querySelectorAll('.btn');
            allButtons.forEach(btn => {
                // Kh√¥ng disable n√∫t logout v√¨ ƒë√£ c√≥ n√∫t ri√™ng ·ªü header
                if (!btn.textContent.includes('L√†m m·ªõi') && !btn.textContent.includes('ƒêƒÉng xu·∫•t') && btn.id !== 'headerLogoutBtn') {
                    btn.disabled = true;
                }
            });
        }

        // ==================== SERIAL SCANNER COM PORT INTEGRATION ====================
        let serialScanner = null;
        let isComConnected = false;
        let userAssignedPort = null; // C·ªïng COM ƒë∆∞·ª£c admin ph√¢n quy·ªÅn
        let currentPort = null; // Port hi·ªán t·∫°i ƒëang k·∫øt n·ªëi
        let currentComPort = null; // T√™n COM port hi·ªán t·∫°i ƒëang k·∫øt n·ªëi
        let isListening = false; // Tr·∫°ng th√°i ƒëang l·∫Øng nghe
        let isConnecting = false; // Tr·∫°ng th√°i ƒëang k·∫øt n·ªëi (tr√°nh claim port li√™n t·ª•c)
        
        // Machine and session tracking
        let machineId = null;
        let sessionId = null;
        let heartbeatInterval = null;

        // Generate unique machine ID (based on browser fingerprint)
        function generateMachineId() {
            if (machineId) return machineId;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Machine ID', 2, 2);
            
            const fingerprint = [
                navigator.userAgent,
                navigator.language,
                screen.width + 'x' + screen.height,
                new Date().getTimezoneOffset(),
                canvas.toDataURL()
            ].join('|');
            
            // Simple hash function
            let hash = 0;
            for (let i = 0; i < fingerprint.length; i++) {
                const char = fingerprint.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            
            machineId = 'MACHINE_' + Math.abs(hash).toString(36);
            return machineId;
        }
        
        // Generate unique session ID (unique per browser tab/window)
        function generateSessionId() {
            if (sessionId) return sessionId;
            
            // T·∫°o session ID d·ª±a tr√™n timestamp + random + tab ID ƒë·ªÉ ƒë·∫£m b·∫£o unique
            const tabId = Math.random().toString(36).substr(2, 8);
            sessionId = 'SESSION_' + Date.now() + '_' + tabId;
            return sessionId;
        }
        
        // Start heartbeat to keep port alive
        function startHeartbeat() {
            if (heartbeatInterval) return;
            
            heartbeatInterval = setInterval(async () => {
                if (currentComPort && isComConnected) {
                    try {
                        await fetch('/api/update-heartbeat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ comPort: currentComPort })
                        });
                    } catch (error) {
                    }
                }
            }, 10000); // Update every 10 seconds
            
        }
        
        // Stop heartbeat
        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        // Kh·ªüi t·∫°o SerialScanner
        function initSerialScanner() {

            // Ki·ªÉm tra browser support
            if (!navigator.serial) {
                const statusEl = document.getElementById('comStatus');
                if (statusEl) statusEl.innerHTML = '<span style="color: #f44336;">Browser kh√¥ng h·ªó tr·ª£</span>';
                const btnEl = document.getElementById('connectComBtn');
                if (btnEl) btnEl.disabled = true;
                return;
            }


            // X·ª≠ l√Ω n√∫t k·∫øt n·ªëi (d√πng ƒë·ªÉ ng·∫Øt k·∫øt n·ªëi ho·∫∑c k·∫øt n·ªëi l·∫°i)
            const connectBtn = document.getElementById('connectComBtn');
            if (connectBtn) {
                connectBtn.addEventListener('click', handleComConnection);
            }
        }

        // X·ª≠ l√Ω k·∫øt n·ªëi/ng·∫Øt k·∫øt n·ªëi COM port
        async function handleComConnection() {
            
            if (isConnecting) {
                return;
            }
            
            if (isComConnected) {
                await disconnectCom();
            } else {
                // Flow m·ªõi: G·ªçi API l·∫•y danh s√°ch COM ports ‚Üí User ch·ªçn ‚Üí Connect
                await showComPortSelection();
            }
        }
        
        // Hi·ªÉn th·ªã dialog ch·ªçn COM port (gi·ªëng debug-client.html)
        async function showComPortSelection() {
            try {
                
                // Set flag ƒëang k·∫øt n·ªëi
                isConnecting = true;
                
                // Ki·ªÉm tra h·ªó tr·ª£ Web Serial API
                if (!navigator.serial) {
                    alert('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Serial API. Vui l√≤ng s·ª≠ d·ª•ng Chrome/Edge m·ªõi nh·∫•t.');
                    isConnecting = false;
                    return;
                }
                
                // Y√™u c·∫ßu user ch·ªçn thi·∫øt b·ªã COM port (gi·ªëng debug-client.html)
                const port = await navigator.serial.requestPort();
                
                const portInfo = port.getInfo();
                
                // L·∫•y t√™n COM port t·ª´ port info ho·∫∑c s·ª≠ d·ª•ng t√™n m·∫∑c ƒë·ªãnh
                let comPortName = 'COM_UNKNOWN';
                
                
                // T·∫°o t√™n unique cho m·ªói port ƒë·ªÉ tr√°nh tr√πng gi·ªØa c√°c user tr√™n c√πng m√°y
                const machineId = generateMachineId();
                const sessionId = generateSessionId();
                const timestamp = Date.now();
                const random = Math.random().toString(36).substr(2, 5);
                
                if (portInfo.path) {
                    // S·ª≠ d·ª•ng path + session ID ƒë·ªÉ ph√¢n bi·ªát user tr√™n c√πng m√°y
                    comPortName = `${portInfo.path}_${sessionId}`;
                } else {
                    // T·∫°o t√™n unique d·ª±a tr√™n timestamp + random + session ID
                    comPortName = `COM_${timestamp}_${random}_${sessionId}`;
                }
                
                
                // Claim port tr·ª±c ti·∫øp (atomic operation, kh√¥ng c·∫ßn check tr∆∞·ªõc)
                const claimResult = await claimPort(comPortName, machineId, sessionId);
                if (!claimResult.success) {
                    alert(claimResult.message);
                    isConnecting = false;
                    return;
                }
                
                // K·∫øt n·ªëi v·ªõi COM port ƒë√£ ch·ªçn
                await connectToSelectedComPort(comPortName, port);
                
                // Reset flag ƒëang k·∫øt n·ªëi
                isConnecting = false;
                
            } catch (error) {
                
                // Reset tr·∫°ng th√°i khi c√≥ l·ªói
                isComConnected = false;
                currentComPort = null;
                currentPort = null;
                isListening = false;
                isConnecting = false;
                
                let errorMsg = 'L·ªói ch·ªçn COM port: ' + error.message;
                if (error.name === 'NotAllowedError') {
                    errorMsg = 'B·∫°n ƒë√£ t·ª´ ch·ªëi quy·ªÅn truy c·∫≠p. Vui l√≤ng th·ª≠ l·∫°i v√† ch·ªçn "Cho ph√©p".';
                } else if (error.name === 'NotFoundError') {
                    errorMsg = 'Kh√¥ng t√¨m th·∫•y COM port. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi thi·∫øt b·ªã.';
                }
                
                alert(errorMsg);
            }
        }
        
        // K·∫øt n·ªëi v·ªõi COM port ƒë√£ ch·ªçn (gi·ªëng debug-client.html)
        async function connectToSelectedComPort(comPort, port) {
            const statusSpan = document.getElementById('comStatus');
            const connectBtn = document.getElementById('connectComBtn');
            
            try {
                statusSpan.innerHTML = `<span style="color: #2196f3;">‚è≥ ƒêang k·∫øt n·ªëi ${comPort}...</span>`;
                connectBtn.disabled = true;
                
                // Ki·ªÉm tra h·ªó tr·ª£ Web Serial API
                if (!navigator.serial) {
                    throw new Error('Browser kh√¥ng h·ªó tr·ª£ Web Serial API');
                }
                
                // ƒê√≥ng port c≈© n·∫øu ƒëang m·ªü
                if (currentPort) {
                    try {
                        await currentPort.close();
                    } catch (closeError) {
                    }
                    currentPort = null;
                }
                
                // Ki·ªÉm tra port ƒë√£ m·ªü ch∆∞a
                if (port.readable) {
                    try {
                        await port.close();
                    } catch (closeError) {
                    }
                }
                
                // Ki·ªÉm tra xem port ƒë√£ ƒë∆∞·ª£c claim b·ªüi ch√≠nh user hi·ªán t·∫°i ch∆∞a
                const currentUser = getCurrentUsername();
                const isPortInUse = await checkPortUsage(comPort);
                
                if (isPortInUse) {
                    throw new Error(`COM port ${comPort} ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi user kh√°c`);
                }
                
                // M·ªü port v·ªõi c·∫•u h√¨nh t·ªëi ∆∞u cho scanner
                // Th·ª≠ nhi·ªÅu baud rate ph·ªï bi·∫øn cho scanner
                const baudRates = [9600, 115200, 38400, 19200, 4800];
                let connected = false;
                
                for (const baudRate of baudRates) {
                    try {
                        await port.open({ 
                            baudRate: baudRate,
                            dataBits: 8,
                            stopBits: 1,
                            parity: 'none',
                            flowControl: 'none'
                        });
                        connected = true;
                        break;
                    } catch (openError) {
                        // ƒê√≥ng port tr∆∞·ªõc khi th·ª≠ baud rate kh√°c
                        try {
                            await port.close();
                        } catch (closeError) {
                            // Ignore close errors
                        }
                    }
                }
                
                if (!connected) {
                    throw new Error('Kh√¥ng th·ªÉ k·∫øt n·ªëi v·ªõi b·∫•t k·ª≥ baud rate n√†o. Vui l√≤ng ki·ªÉm tra thi·∫øt b·ªã scanner.');
                }
                
                
                // L∆∞u port v√† t√™n COM port ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y
                currentPort = port;
                currentComPort = comPort;
                
                // C·∫≠p nh·∫≠t status th√†nh c√¥ng
                isComConnected = true;
                statusSpan.innerHTML = `<span style="color: #4caf50;"> ƒê√£ k·∫øt n·ªëi ${comPort}</span>`;
                connectBtn.textContent = 'üîå Ng·∫Øt k·∫øt n·ªëi COM';
                connectBtn.style.background = '#f44336';
                connectBtn.disabled = false;
                
                // Start heartbeat ƒë·ªÉ keep port alive
                startHeartbeat();
                
                // B·∫Øt ƒë·∫ßu ƒë·ªçc d·ªØ li·ªáu v·ªõi buffer ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu ƒë·∫ßy ƒë·ªß
                let dataBuffer = '';
                const reader = port.readable.getReader();
                isListening = true;
                
                
                // L·∫Øng nghe d·ªØ li·ªáu li√™n t·ª•c
                while (isListening) {
                    try {
                        const { value, done } = await reader.read();
                        
                        if (done) {
                            break;
                        }
                        
                        // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu th√†nh string v√† th√™m v√†o buffer
                        const chunk = new TextDecoder().decode(value);
                        dataBuffer += chunk;
                        
                        
                        // Ki·ªÉm tra k√Ω t·ª± k·∫øt th√∫c (th∆∞·ªùng l√† \r\n, \n, ho·∫∑c \r)
                        if (dataBuffer.includes('\n') || dataBuffer.includes('\r')) {
                            // T√°ch d·ªØ li·ªáu ho√†n ch·ªânh t·ª´ buffer
                            const lines = dataBuffer.split(/[\r\n]+/);
                            
                            // X·ª≠ l√Ω t·∫•t c·∫£ d√≤ng ho√†n ch·ªânh (tr·ª´ d√≤ng cu·ªëi n·∫øu ch∆∞a k·∫øt th√∫c)
                            for (let i = 0; i < lines.length - 1; i++) {
                                const line = lines[i].trim();
                                
                                if (line) {
                                    
                                    // G·ª≠i d·ªØ li·ªáu l√™n server ƒë·ªÉ log
                                    sendComInputToServer(currentComPort, line);
                                    
                                    // ƒê∆∞a d·ªØ li·ªáu v√†o input field v√† t·ª± ƒë·ªông x·ª≠ l√Ω
                                    const input = document.getElementById('codeInput');
                                    if (input) {
                                        // T·ª± ƒë·ªông ƒë√≥ng modal tr∆∞·ªõc khi x·ª≠ l√Ω d·ªØ li·ªáu
                                        hideModal();
                                        
                                        // Focus v√†o input field
                                        input.focus();
                                        
                                        // ƒêi·ªÅn d·ªØ li·ªáu
                                        input.value = line;
                                        
                                        // Trigger input event ƒë·ªÉ c√°c listener kh√°c c√≥ th·ªÉ x·ª≠ l√Ω
                                        input.dispatchEvent(new Event('input', { bubbles: true }));
                                        
                                        // T·ª± ƒë·ªông x·ª≠ l√Ω d·ªØ li·ªáu sau 100ms
                                        setTimeout(() => {
                                            try {
                                                // ƒê·∫£m b·∫£o modal ƒë∆∞·ª£c ƒë√≥ng tr∆∞·ªõc khi x·ª≠ l√Ω
                                                hideModal();
                                                handleEnter(line);
                                            } catch (e) {
                                            }
                                        }, 100);
                                    }
                                }
                            }
                            
                            // Gi·ªØ l·∫°i ph·∫ßn d·ªØ li·ªáu ch∆∞a ho√†n ch·ªânh trong buffer
                            dataBuffer = lines[lines.length - 1];
                        }
                        
                    } catch (readError) {
                        break;
                    }
                }
                
            } catch (error) {
                statusSpan.innerHTML = `<span style="color: #f44336;">L·ªói k·∫øt n·ªëi ${comPort}: ${error.message}</span>`;
                
                // Reset tr·∫°ng th√°i khi c√≥ l·ªói
                isComConnected = false;
                currentComPort = null;
                currentPort = null;
                isListening = false;
                isConnecting = false;
                
                connectBtn.textContent = 'üîå K·∫øt n·ªëi m√°y qu√©t COM';
                connectBtn.style.background = '#2196f3';
                connectBtn.disabled = false;
            }
        }
        
        // G·ª≠i d·ªØ li·ªáu COM port l√™n server
        async function sendComInputToServer(comPort, inputData) {
            try {
                const username = getCurrentUsername();
                const currentSessionId = generateSessionId();
                
                
                const response = await fetch('/api/com-input', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userId: username || 'unknown_user',
                        comPort: comPort,
                        inputData: inputData.trim(),
                        timestamp: new Date().toISOString(),
                        sessionId: currentSessionId
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                } else {
                }
                
            } catch (error) {
            }
        }
        
        // L·∫•y username hi·ªán t·∫°i
        function getCurrentUsername() {
            try {
                const token = sessionStorage.getItem('auth_token') || sessionStorage.getItem('checkerAuthToken');
                if (token) {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    return payload.username;
                }
                return null;
            } catch (error) {
                return null;
            }
        }

        // K·∫øt n·ªëi COM port
        async function connectCom() {
            const statusSpan = document.getElementById('comStatus');
            const connectBtn = document.getElementById('connectComBtn');

            try {
                statusSpan.innerHTML = '<span style="color: #2196f3;">‚è≥ ƒêang k·∫øt n·ªëi...</span>';
                connectBtn.disabled = true;

                // Y√™u c·∫ßu ch·ªçn port
                await serialScanner.requestPort();

                // K·∫øt n·ªëi v·ªõi baudRate 9600 (c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh)
                await serialScanner.connect(9600);

                // B·∫Øt ƒë·∫ßu ƒë·ªçc d·ªØ li·ªáu
                serialScanner.startReading((scannedData) => {
                    
                    // T·ª± ƒë·ªông ƒë√≥ng modal tr∆∞·ªõc khi x·ª≠ l√Ω d·ªØ li·ªáu
                    hideModal();
                    
                    const input = document.getElementById('codeInput');
                    if (input) {
                        input.value = scannedData;
                        try {
                            // ƒê·∫£m b·∫£o modal ƒë∆∞·ª£c ƒë√≥ng tr∆∞·ªõc khi x·ª≠ l√Ω
                            hideModal();
                            handleEnter(scannedData);
                        } catch (e) {
                        }
                        input.value = '';
                    }
                });

                isComConnected = true;
                statusSpan.innerHTML = '<span style="color: #4caf50;"> ƒê√£ k·∫øt n·ªëi</span>';
                connectBtn.textContent = 'üîå Ng·∫Øt k·∫øt n·ªëi COM';
                connectBtn.style.background = '#f44336';
                connectBtn.disabled = false;

                
            } catch (error) {
                statusSpan.innerHTML = '<span style="color: #f44336;">' + error.message + '</span>';
                connectBtn.disabled = false;
                isComConnected = false;
            }
        }

        // Ng·∫Øt k·∫øt n·ªëi COM port
        async function disconnectCom() {
            const statusSpan = document.getElementById('comStatus');
            const connectBtn = document.getElementById('connectComBtn');

            try {
                statusSpan.innerHTML = '<span style="color: #ff9800;">‚è≥ ƒêang ng·∫Øt k·∫øt n·ªëi...</span>';
                
                // D·ª´ng vi·ªác ƒë·ªçc d·ªØ li·ªáu tr∆∞·ªõc
                isListening = false;
                
                // Release port t·ª´ database
                if (currentComPort) {
                    try {
                        await releasePort(currentComPort);
                    } catch (releaseError) {
                    }
                }
                
                // Ng·∫Øt k·∫øt n·ªëi COM port
                if (currentPort) {
                    try {
                        await currentPort.close();
                    } catch (closeError) {
                    }
                    currentPort = null;
                } else {
                }
                
                // Stop heartbeat
                stopHeartbeat();
                
                // C·∫≠p nh·∫≠t tr·∫°ng th√°i
                isComConnected = false;
                currentComPort = null; // Reset COM port name
                currentPort = null; // Reset COM port object
                isListening = false; // Reset listening state
                isConnecting = false; // Reset connecting state
                statusSpan.innerHTML = '<span style="color: #999;">‚ö´ Ch∆∞a k·∫øt n·ªëi</span>';
                connectBtn.textContent = 'üîå K·∫øt n·ªëi m√°y qu√©t COM';
                connectBtn.style.background = '#2196f3';
                connectBtn.disabled = false;

                
            } catch (error) {
                statusSpan.innerHTML = '<span style="color: #f44336;">L·ªói ng·∫Øt k·∫øt n·ªëi</span>';
                
                // Force reset tr·∫°ng th√°i ngay c·∫£ khi c√≥ l·ªói
                isComConnected = false;
                isListening = false;
                currentPort = null;
                isConnecting = false;
                connectBtn.textContent = 'üîå K·∫øt n·ªëi m√°y qu√©t COM';
                connectBtn.style.background = '#2196f3';
                connectBtn.disabled = false;
            }
        }

        // Ki·ªÉm tra xem COM port ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng ch∆∞a (deprecated - d√πng atomic claim thay th·∫ø)
        async function checkPortUsage(comPortName) {
            try {
                
                // G·ªçi API ki·ªÉm tra port usage
                const response = await fetch('/api/check-port-usage', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ comPort: comPortName })
                });
                
                const result = await response.json();
                
                // Ki·ªÉm tra xem port c√≥ ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi user kh√°c kh√¥ng
                if (result.isInUse && result.currentUser && result.currentUser !== getCurrentUsername()) {
                    return true;
                }
                
                return false;
                
            } catch (error) {
                // N·∫øu kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c, t·ª´ ch·ªëi k·∫øt n·ªëi ƒë·ªÉ tr√°nh conflict
                return true;
            }
        }
        
        // Claim port khi k·∫øt n·ªëi (atomic operation)
        async function claimPort(comPortName, machineIdParam = null, sessionIdParam = null) {
            try {
                
                // S·ª≠ d·ª•ng machineId v√† sessionId ƒë∆∞·ª£c truy·ªÅn v√†o ho·∫∑c t·∫°o m·ªõi
                const machineId = machineIdParam || generateMachineId();
                const sessionId = sessionIdParam || generateSessionId();
                const screenId = 'main'; // Default screen, could be enhanced for multiple screens
                
                // G·ªçi API claim port v·ªõi atomic transaction
                const response = await fetch('/api/claim-port', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        comPort: comPortName,
                        machineId: machineId,
                        sessionId: sessionId,
                        screenId: screenId
                    })
                });
                
                const result = await response.json();
                
                return result;
                
            } catch (error) {
                return {
                    success: false,
                    message: 'L·ªói claim port: ' + error.message
                };
            }
        }
        
        // Release port khi ng·∫Øt k·∫øt n·ªëi
        async function releasePort(comPortName) {
            try {
                
                // G·ªçi API release port cho b·∫•t k·ª≥ user n√†o
                const response = await fetch('/api/release-port-any', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ comPort: comPortName })
                });
                
                const result = await response.json();
                
                return result;
                
            } catch (error) {
                return {
                    success: false,
                    message: 'L·ªói release port: ' + error.message
                };
            }
        }
        
        // Release port cho b·∫•t k·ª≥ user n√†o (d√πng khi logout)
        async function releasePortForAnyUser(comPortName) {
            try {
                
                // G·ªçi API release port cho b·∫•t k·ª≥ user n√†o
                const response = await fetch('/api/release-port-any', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ comPort: comPortName })
                });
                
                const result = await response.json();
                
                return result;
                
            } catch (error) {
                return {
                    success: false,
                    message: 'L·ªói release port: ' + error.message
                };
            }
        }
        
        // Ki·ªÉm tra tr·∫°ng th√°i COM port
        function checkComPortStatus() {
            
            const statusSpan = document.getElementById('comStatus');
            const connectBtn = document.getElementById('connectComBtn');
            
            // Ki·ªÉm tra port usage trong database
            if (currentComPort) {
                checkPortUsage(currentComPort).then(result => {
                });
            }
        }
        
        // ========== STATE MACHINE COMPATIBILITY FUNCTIONS ==========
        
        // X√°c nh·∫≠n ho√†n th√†nh ƒë∆°n v·∫≠n ƒë∆°n (t∆∞∆°ng th√≠ch v·ªõi State Machine)
        async function confirmVanDonComplete() {
            try {
                if (orderCheckSM.currentOrder) {
                    // S·ª≠ d·ª•ng State Machine
                    await orderCheckSM.completeOrder();
                } else {
                    // Fallback cho logic c≈©
                    const response = await fetch('/api/orders/complete-van-don', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + getAuthToken()
                        },
                        body: JSON.stringify({
                            maVanDon: currentMaVanDon
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        setStatus('ƒê√£ x√°c nh·∫≠n ho√†n th√†nh ƒë∆°n v·∫≠n ƒë∆°n!', 'ok');
                        ensureInputFocus();
                        
                        // Reset tr·∫°ng th√°i qu√©t sau khi x√°c nh·∫≠n ho√†n th√†nh
                        orderCheckState = 'idle';
                        scannedItems = [];
                        currentMaVanDon = '';
                        setCacheOrders([], 'reset-after-cancel');
                        waitingForNewOrder = false;
                        
                        showModal({
                            type: 'success',
                            title: 'Ho√†n th√†nh!',
                            message: result.message,
                            timeout: 2000
                        });
                    } else {
                        setStatus('L·ªói x√°c nh·∫≠n: ' + result.message, 'err');
                        ensureInputFocus();
                        
                        showModal({
                            type: 'error',
                            title: 'L·ªói x√°c nh·∫≠n',
                            message: result.message
                        });
                    }
                }
                
            } catch (error) {
                setStatus('L·ªói x√°c nh·∫≠n ƒë∆°n v·∫≠n ƒë∆°n: ' + error.message, 'err');
                ensureInputFocus();
                
                showModal({
                    type: 'error',
                    title: 'L·ªói k·∫øt n·ªëi',
                    message: 'L·ªói x√°c nh·∫≠n ƒë∆°n v·∫≠n ƒë∆°n: ' + error.message
                });
            }
        }
        
        // Chuy·ªÉn sang ƒë∆°n kh√°c (t∆∞∆°ng th√≠ch v·ªõi State Machine)
        function switchToNewOrder() {
            if (orderCheckSM.currentOrder) {
                // S·ª≠ d·ª•ng State Machine
                orderCheckSM.reset();
                setStatus('ƒê√£ reset. H√£y t√¨m ƒë∆°n h√†ng m·ªõi.', 'info');
                ensureInputFocus();
            } else {
                // Fallback cho logic c≈©
                // KH√îNG cho ph√©p chuy·ªÉn ƒë∆°n khi ƒë√£ c√≥ ƒë∆°n h√†ng trong qtext
                if (currentMaVanDon) {
                    setStatus(`ƒê√£ c√≥ ƒë∆°n ${currentMaVanDon} ƒëang x·ª≠ l√Ω, kh√¥ng th·ªÉ chuy·ªÉn ƒë∆°n kh√°c`, 'err');
                    showModal({
                        type: 'warning',
                        title: 'Kh√¥ng th·ªÉ chuy·ªÉn ƒë∆°n',
                        message: `ƒê√£ c√≥ ƒë∆°n ${currentMaVanDon} ƒëang x·ª≠ l√Ω. Vui l√≤ng ho√†n th√†nh ho·∫∑c h·ªßy ƒë∆°n hi·ªán t·∫°i tr∆∞·ªõc khi chuy·ªÉn ƒë∆°n kh√°c.`
                    });
                    return;
                }
                
                // Unblock ƒë∆°n hi·ªán t·∫°i tr∆∞·ªõc khi chuy·ªÉn
                if (currentMaVanDon) {
                    fetch('/api/orders/unblock-van-don', {
                        method: 'POST',
                        credentials: 'include',
                        headers: { 
                            'Content-Type': 'application/json', 
                            'Authorization': 'Bearer ' + getAuthToken() 
                        },
                        body: JSON.stringify({ maVanDon: currentMaVanDon })
                    }).catch(e => {});
                }
                
                // Reset tr·∫°ng th√°i qu√©t
                orderCheckState = 'idle';
                scannedItems = [];
                currentMaVanDon = '';
                cacheOrders = [];
                currentVanDonStatus = null;
                waitingForNewOrder = true; // Cho ph√©p input ƒë∆°n m·ªõi
                document.getElementById('maVanDonTag').textContent = 'Ch∆∞a ch·ªçn';
                
                // C·∫≠p nh·∫≠t giao di·ªán
                renderQueue();
                renderOrders();
                setStatus('ƒê√£ reset. H√£y t√¨m ƒë∆°n h√†ng m·ªõi.', 'info');
                ensureInputFocus();
            }
        }
        
        // Kh·ªüi t·∫°o khi trang load
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                initSerialScanner();
                // loadScannerInfo(); // Function kh√¥ng t·ªìn t·∫°i, ƒë√£ ƒë∆∞·ª£c g·ªçi trong loadMyScannerPermissions()
            }, 500);
        });
        
        // ƒê√≥ng t·∫•t c·∫£ ports khi trang ƒë∆∞·ª£c unload
        window.addEventListener('beforeunload', async function() {
            if (isComConnected && currentComPort) {
                try {
                    
                    // D·ª´ng ƒë·ªçc d·ªØ li·ªáu
                    isListening = false;
                    
                    // Stop heartbeat
                    stopHeartbeat();
                    
                    // X√≥a b·∫£n ghi port t·ª´ database
                    if (currentComPort) {
                        try {
                            await fetch('/api/delete-port', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ comPort: currentComPort })
                            });
                        } catch (deleteError) {
                        }
                    }
                    
                    // ƒê√≥ng COM port
                    if (currentPort) {
                        await currentPort.close();
                    }
                    
                    // Reset tr·∫°ng th√°i
                    isComConnected = false;
                    currentComPort = null;
                    currentPort = null;
                    
                } catch (error) {
                }
            }
        });

        // ==================== END SCANNER INFO FUNCTIONS ====================
    </script>
</body>
</html>
